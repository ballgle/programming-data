# C++ 类

C++ 在 C 语言的基础上增加了面向对象编程，而类是 C++ 的核心特性，通常被称为用户定义的类型。类具备了两个功能：

- 1 数据抽象：定义数据和函数的能力；数据抽象是一种依赖于接口和实现分离的编程（和设计）技术。类设计者必须关心类是如何实现的，但使用该类的程序员不必了解这些细节。相反，使用一个类型的程序员仅需了解类型的接口，他们可以抽象地考虑该类型做什么，而不必具体地考虑该类型如何工作。
- 2 封装：封装是一项低层次的元素组合起来的形成新的、高层次实体珠技术。函数是封装的一种形式：函数所执行的细节行为被封装在函数本身这个更大的实体中，而内的成员数据和成员函数也不会随便被外部访问。标准库类型 `string`、`istream` 和 `ostream` 都定义成类。

C++ 面向对象特征：

- 封装：类的定义
- 继承：实现继承(非虚函数)、可视继承(虚函数)、接口继承(纯虚函数)
- 多态
  - 覆盖：虚函数、接口
  - 重载：同名函数

---
## 1 类的声明与定义

### 定义类

定义类就是定义了一个新的类型和一个新作用域。c++中使用 **struct** 或 **class** 定义类，struct 与 class唯一的区别就是默认的访问权限不一样。

- struct 的第一个访问说明符之前所有的成员都是`public`的
- class 的第一个访问说明符之前所有的成员都是`private`的

仅当只有数据时使用 struct，其它一概使用 class。

```cpp
#ifndef C_BASIC_CLASS1_H
#define C_BASIC_CLASS1_H

#include <iostream>

class Box {

private:
    double length;   // 盒子的长度
    double breadth;  // 盒子的宽度
    double height;   // 盒子的高度

public:
    double getVolume() {
        return length * breadth * height;
    }

    void setLength(double len);

    void setBreadth(double bre);

    void setHeight(double hei);

    void printBoxInfo() const {
        std::cout << "length = " << length << "breadth = " << breadth << "height = " << height << std::endl;
    }

};

//单独使用范围解析运算符 :: 来定义。
void Box::setLength(double len) {
    length = len;
}

void Box::setBreadth(double bre) {
    breadth = bre;
}

void Box::setHeight(double hei) {
    height = hei;
}


#endif //C_BASIC_CLASS1_H
```

### 声明类

可以先声明一个类，而不定义：

```cpp
class Screen; // declaration of the Screen class
```

**前向声明**（forward declaraton）：在程序中引入了类类型的 Screen。在声明之后、定义之前，类 Screen 是一个不完全类型（incompete type），即已知 Screen 是一个类型，但不知道包含哪些成员。

**不完全类型**：不完全类型（incomplete type）只能以有限方式使用。不能定义该类型的对象。不完全类型只能用于定义指向该类型的指针及引用，或者用于声明（而不是定义）使用该类型作为形参类型或返回类型的函数。

**什么时候需要使用向前声明**：

- 为类的成员使用类声明。
- 编写相互依赖的类。

**声明类的限制**：在创建类的对象之前，必须完整地定义该类。必须定义类，而不只是声明类，这样，编译器就会给类的对象预定相应的存储空间。同样地，在使用引用或指针访问类的成员之前，必须已经定义类。

- 只有当类定义已经在前面出现过，数据成员才能被指定为该类类型。如果该类型是不完全类型，那么数据成员只能是指向该类类型的指针或引用。
- 因为只有当类定义体完成后才能定义类，因此类不能具有自身类型的数据成员。然而，只要类名一出现就可以认为该类已声明。因此，类的数据成员可以是指向自身类型的指针或引用。

```cpp
  class LinkScreen {
    Screen window;
    //因为到这里时，LinkScreen 还没有完成定义，数据成员只能是指向该类类型的指针或引用。
    LinkScreen *next;
    LinkScreen *prev;
  };
```

### 类的定义分号结束

类的定义分号结束。分号是必需的，因为在类定义之后可以接一个对象定义列表。定义必须以分号结束：

```cpp
class Box { /* ... */ };
class Box { /* ... */ } boxA, boxB;
```

### 使用前置声明还是 include

参考[如何看待C++前置声明？](https://www.zhihu.com/question/63201378)

---
## 2 类的成员

每个类可以没有成员，也可以定义多个成员，成员可以是数据、函数或类型别名。一个类可以包含若干公有的、私有的和受保护的部分。所有成员必须在类的内部声明，一旦类定义完成后，就没有任何方式可以增加成员了。

类的成员包括：

- 构造函数：创建一个类类型的对象时，编译器会自动使用一个构造函数来初始化该对象。构造函数是一个特殊的、与类同名的成员函数，用于给每个数据成员设置适当的初始值。
- 成员函数：类的成员函数是指那些**把定义和原型写在类定义内部的函数**，就像类定义中的其他变量一样。类成员函数是类的一个成员。类成员函数可以只在类内声明，然后在类外使用范围解析运算符`::`来定义，也可以直接定义在类中，在类中定义的成员函数默认是内联的，即便没有使用 `inline`标识符。

### const 成员函数

将关键字 const 加在形参表之后，就可以将成员函数声明为常量：

```cpp
    //printBoxInfo 只能读取成员，而不能修改成员。
    void printBoxInfo() const {
        std::cout << "length = " << length << "breadth = " << breadth << "height = " << height << std::endl;
    }
```

**const 成员不能改变其所操作的对象的数据成员**。 const 必须同时出现在声明和定义中，若只出现在其中一处，就会出现一个编译时错误。

### 定义 inline 函数

**类的内联函数定义规则**：

- 在类中定义的成员函数默认是内联的，即便没有使用 `inline`标识符。
- 可以在类定义体内部指定一个成员为 inline，作为其声明的一部分。或者，也可以在类定义外部的函数定义上指定 inline。在声明和定义处指定 inline 都是合法的。在类的外部定义 inline 的一个好处是可以使得类比较容易阅读。
- 像其他 inline 一样，inline 成员函数的定义必须在调用该函数的每个源文件中是可见的。不在类定义体内定义的 inline 成员函数，其定义通常应放在有类定义的同一头文件中。

**在定义于类外部的内联函数中的最佳实践**：

以下哪种方法最好：是把inline关键字放在类内部的成员函数声明前呢，还是放到类外部函数的定义前呢，还是两个地方都写？最佳实践是：仅放在类外部函数的定义前：

```cpp
 class Foo {
 public:
   void method();  ← best practice: don't put the inline keyword here
   ...
 };

inline void Foo::method()  ← best practice: put the inline keyword here{ ... }
```

- 类的public部分是你描述类的可见语义的地方，包含公有成员函数、友元函数和任何其它暴露给外部的内容。不要提供在调用者代码中看不到的细节。
- 类的其它部分，包括非公有部分、成员定义和友元函数声明等等，这些纯粹是实现细节。如果还没有在类的公有部分描述，那么不要提供相关可见语义。

具体参考[C++ FAQ LITE——内联函数](http://www.sunistudio.com/cppfaq/inline-functions.html)。

### mutable 成员

有时，我们希望类的数据成员(甚至在 const 成员函数内)可以修改。这可以通过将它们声明为 `mutable` 来实现。可变数据成员（mutable data member）永远都不能为 const，甚至当它是 const 对象的成员时也如此。

```cpp
class Screen {
public:
  // 省略公共成员
private:
  mutable size_t access_ctr; //这个成员可以在const成员函数中被修改
};

//给 Screen 添加了一个新的可变数据成员 access_ctr。使用 access_ctr 来跟踪调用 Screen 成员函数的频繁程度
//尽管 do_display 是 const，它也可以增加 access_ctr。该成员是可变成员，所以，任意成员函数，包括 const 函数，都可以改变 access_ctr 的值。
void Screen::do_display(std::ostream& os) const {
  ++access_ctr; //自增修改
  os << contents;
}
```

### this 指针

在 C++ 中，每一个对象都能通过 `this` 指针来访问自己的地址。`this` 指针是所有成员函数( static 成员函数除外)的隐含参数。因此在成员函数内部，它可以用来指向调用对象。

- 在普通的非 const 成员函数中，this 的类型是一个指向类类型的 const 指针。可以改变 this 所指向的值，但不能改变 this 所保存的地址。
- 在 const 成员函数中，this 的类型是一个指向 const 类类型对象的 const 指针。既不能改变 this 所指向的对象，也不能改变 this 所保存的地址。
- **友元函数没有 this 指针**，因为友元不是类的成员。只有成员函数才有 this 指针。
- 不能从 const 成员函数返回指向类对象的普通引用。const 成员函数只能返回 *this 作为一个 const 引用。

在返回类型引用的函数中，使用`* this`返回对象表示返回的是对象本身，而不是对象的拷贝：

```cpp
Box& Box::combine(const Box &rhs){
    ......
    return *this;
}
```

---
## 3 类的成员访问修饰符

- `public`公有成员在程序中类的外部是可访问的。可以不使用任何成员函数来设置和获取公有变量的值。
- `private`私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。
- `protected`保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。

---
## 4 作用域中的名字查找

**名字查找**：寻找与给定的名字使用相匹配的声明的过程

**普通名字查找过程**：

1. 首先，在使用该名字的块中查找名字的声明，只考虑在该项使用之前声明的名字。
2. 如果找不到该名字，则在包围的作用域中查找。
3. 如果找不到任何声明，则程序出错。在 C++ 程序中，所有名字必须在使用之前声明。

对于名字查找，类定义实际上是在两个阶段中处理：

1. 编译成员声明。
2. 只有在所有成员出现之后，才编译它们的定义本身。

**类成员声明的名字查找过程**：

1. 检查出现在名字使用之前的类成员的声明。
2. 如果第 1 步查找不成功，则检查包含类定义的作用域中出现的声明以及出现在类定义之前的声明。

必须在类中先定义类型名字，才能将它们用作数据成员的类型，或者成员函数的返回类型或形参类型。

**类成员定义中的名字查找过程（函数内）**：

1. 首先检查成员函数局部作用域中的声明。
2. 如果在成员函数中找不到该名字的声明，则检查对所有类成员的声明。
3. 如果在类中找不到该名字的声明，则检查在此成员函数定义之前的作用域中出现的声明。

---
## 5 构造函数

构造函数是特殊的成员函数，只要创建类类型的新对象，都要执行构造函数。构造函数的工作是保证每个对象的数据成员具有合适的初始值，**构造函数通常应确保其每个数据成员都完成了初始化**：

下面是类的初始化规则：

- 类里面的任何成员变量在定义时是不能初始化的，即在定义类时不能初始化它的数据成员，而是通过构造函数来初始化其数据成员。
- 一般的数据成员可以在构造函数中初始化，构造函数的形参指定了创建类类型对象时使用的初始化式，一般这些初始化式会用于初始化新创建对象的数据成员。
- const 数据成员必须在构造函数的初始化列表中初始化。
- 对于一些类类型的成员，构造函数会将其初始化为合理的默认状态。
- static 要在类的定义外面初始化。
- 数组成员不能在初始化列表里初始化的。

参照下面类定义：

```cpp
class Sales_item {
public:

  double avg_price() const;
  
  bool same_isbn(const Sales_item &rhs) const {
        return isbn == rhs.isbn;
  }
  
  //初始化列表
  Sales_item(): units_sold(0), revenue(0.0) { }
  
  Sales_data &combine(const Sales_data &);
  
private:
  std::string isbn;//默认构造函数将其初始化为 ""
  unsigned units_sold;
  double revenue;
};
```

### 5.1 定义构造函数

- 构造函数允许重载，即其数量没有限制。
- 构造函数不能声明为 const，构造函数本就是为了初始化类成员。

### 5.2 默认构造函数

如果类没有定义构造函数，则编译器会生成默认的构造函数，这也称为(合成的默认构造函数 synthesized default constructor)，默认构造函数，**将依据如同变量初始化的规则初始化类中所有成员** (这是合成的默认构造函数的功能)。

- 对于具有类类型的成员，如 string，则会调用该成员所属类自身的默认构造函数实现初始化。
- 内置类型成员的初值依赖于对象如何定义：
  - 如果对象在 **全局作用域** 中定义(即不在任何函数中)或定义为静态局部对象，则这些成员将被初始化为 0。
  - 如果对象在 **局部作用域** 中定义，则这些成员没有初始化(未知的)。除了给它们赋值之外，出于其他任何目的对未初始化成员的使用都没有定义。

**即内置类型的成员变量的”默认初始化”行为取决于所在对象的存储类型，而存储类型对应的默认初始化规则是不变的。并且类中成员对象的内置类型成员变量的”默认初始化”行为取决于当前封闭类对象的存储类型，而存储类型对应的默认初始化规则仍然是不变的。**

注意：**合成的默认构造函数只适用于简单的类**：

1. 编译器只有在发现不包含任何构造函数的情况下才会替我们生成一个默认的构造函数：如果一个类在某种情况下需要控制对象的初始化，那么该类很可能再所有情况下都需要控制。
2. 合成的默认构造函数可能执行错误的操作：如果类包含内置或复合类型的成员，则该类不应该依赖于合成的默认构造函数。它应该定义自己的构造函数来初始化这些成员，否则它们的初始化将会是未知的。
3. 有时候编译器不能为某些类合成默认的构造函数，例如如果类中包含一个其他类型的类成员，且这个成员的类型没有默认的构造函数时，那么编译器无法初始化该成员。

**没有默认构造函数的类意味着什么**？假定有一个类 NoDefault，它没有定义自己的默认构造函数，却有一个接受一个string 实参的构造函数。因为该类定义了一个构造函数，因此编译器将不合成默认构造函数。则:

- 具有 NoDefault 成员的每个类的每个构造函数，必须通过传递一个初始的 string 值给 NoDefault 构造函数来显式地初始化 NoDefault 成员。
- 编译器将不会为具有 NoDefault 类型成员的类合成默认构造函数。如果这样的类希望提供默认构造函数，就必须显式地定义，并且默认构造函数必须显式地初始化其 NoDefault 成员。
- NoDefault 类型不能用作动态分配数组的元素类型。
- NoDefault 类型的静态分配数组必须为每个元素提供一个显式的初始化式。
- 如果有一个保存 NoDefault 对象的容器，例如 vector，就不能使用接受容器大小而没有同时提供一个元素初始化式的构造函数。

**类通常应定义一个默认构造函数**。

使用默认构造函数：

```cpp
Sales_item myobj;//正确，定义了一个Sales_item。
Sales_item myobj();//错误，声明了一个函数。
Sales_item myobj = Sales_item();//正确，创建并初始化一个 Sales_item 对象，然后用它来按值初始化 myobj。
```

#### `= default`（C++11）

在 C++11 中，如果定义的构造函数需要默认行为，可以使用以下方式定义：

```cpp
class A{
public:
  A() = default;
}
```

### 5.3 初始化列表

构造函数也可以包含一个构造函数初始化列表，在 **冒号和花括号之间的代码** 称为构造函数的初始化列表，构造函数的初始化列表为类的一个或多个数据成员指定初值。

```cpp
Sales_item(): units_sold(0), revenue(0.0) { }
```

**初始化列表的作用**：有些成员必须在构造函数初始化列表中进行初始化。对于这样的成员，在构造函数函数体中对它们赋值不起作用。**没有默认构造函数的类类型的成员**，以及 **`const` 或引用类型的成员**，不管是哪种类型，都必须在构造函数初始化列表中进行初始化。

参考下面构造函数定义：

```cpp
Sales_item::Sales_item(const string &book){
  isbn = book;
  units_sold = 0;
  revenue = 0.0;
}
```

在构造函数体中对成员进程赋值并不是初始化，C++ 中，执行到函数体时，成员都经过了默认初始化。isbn 首先被初始化为空字符串，然后被用 book 进行赋值。

可以认为构造函数分两个阶段执行：

1. 初始化阶段；不管成员是否在构造函数初始化列表中显式初始化，类类型的数据成员总是在初始化阶段初始化。初始化发生在计算阶段开始之前。
2. 普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。

**类类型的数据成员的初始化式**：初始化类类型的成员时，要指定实参并传递给成员类型的一个构造函数。可以使用该类型的任意构造函数，下面 isbn 的初始化使用了 string 多个构造函数中的的一个。

```cpp
Sales_item(): isbn(10, '9'), units_sold(0), revenue(0.0) {}
```

### 5.4 成员的初始化顺序

1. 构造函数初始化列表仅指定用于初始化成员的值，并不指定这些初始化执行的次序。成员被初始化的次序就是定义成员的次序。第一个成员首先被初始化，然后是第二个，依次类推。
2. 按照与成员声明一致的次序编写构造函数初始化列表是个好主意。此外，尽可能避免使用成员来初始化其他成员。

参考下面类定义，初始化时将会导致错误：

```cpp
class X {
  int i;
  int j;
  public:
  // run-time error: i is initialized before j
  X(int val): j(val), i(j) { }
};
```

### 5.5 默认实参与构造函数

构造函数也允许定义默认参数，参考下面代码：

```cpp
Slass Sales_item {
  public:
  // default argument for book is the empty string
  Sales_item(const std::string &book = ""):  isbn(book), units_sold(0), revenue(0.0) { }

  Sales_item(std::istream &is);
};
```

### 5.6 隐式的类型转换

C++在内置类型中定义了自动类型转换规则，我们也可以为类定义自动类型转换规则，如果构造函数只接收一个实参，则它实际上定义了转换为此类型的隐式转换机制，有时把这种构造函数称为**转换构造函数**

加上我们调用上面定义的`Sales_data`类的`combine`函数：

```cpp
string null_book = "999-999-999-0"
Sales_data item;
//这是合法的，这里应用了隐式类型转换规则，因为 Sales_data 有一个以 string 为参数的构造函数。
item.combine(null_book);
```

隐式的类型转换只允许一步类型转换：

```cpp
Sales_data item;
//这是非法的，因为有两步转换，"999-999-999-0"->string, string->Sales_data（在C++中，字符串字面值与string并不是同一类型）
item.combine("999-999-999-0")
```

#### 抑制由构造函数定义的隐式转换：explicit

除非有明显的理由想要定义**隐式转换**，否则，单形参构造函数应该为 `explicit`。将构造函数设置为 `explicit` 可以避免错误，并且当转换有用时，用户可以显式地构造对象。

下面使用`explicit`抑制由构造函数定义的隐式转换：

```cpp
//此时没有任何构造函数能够隐式的创建Sales_item对象
class Sales_item {
public:
    explicit Sales_item(const std::string &book = ""): isbn(book), units_sold(0), revenue(0.0) {}
    explicit Sales_item(std::istream &is);
};
```

`explicit` 关键字只能用于类内部的构造函数声明上。在类的定义体外部所做的定义上不需要再重复它。

### 5.7 聚合类

聚合类（aggregate class）允许利用者直接访问其成员，并且具有特殊的初始化形式。满足以下条件的类为聚合类：

- 没有定义构造函数。
- 全体数据成员均为 public。
- 没有类内初始值。
- 没有基类，也没有 virtual 函数。

对于聚合类，可以采用与初始化数组元素相同的方式初始化其成员：

```cpp
struct Data {
  int ival;
  char *ptr;
};

// 这种形式的初始化从 C 继承而来，支持与 C 程序兼容：

// val1.ival = 0; val1.ptr = 0
Data val1 = { 0, 0 };

// val2.ival = 1024;
// val2.ptr = "Anna Livia Plurabelle"
Data val2 = { 1024, "Anna Livia Plurabelle"};
```

显式初始化类类型对象的成员有三个重大的缺点：

- 要求类的全体数据成员都是 public。
- 将初始化每个对象的每个成员的负担放在程序员身上，这样的初始化是乏味且易于出错的，因为容易遗忘初始化式或提供不适当的初始化式。
- 如果增加或删除一个成员，必须找到所有的初始化并正确更新。

### 5.8 委托构造函数（C++11）

C++11 新标准扩展了构造函数初始化值的功能，可以定义委托构造函数。即一个构造函数可以委托另一个构造函数进行对象创建。

```cpp
class Sales_item {
public:
    //定义构造函数
    Sales_item(std::string &book, unsigned cnt, double price): isbn(book), units_sold(cnt), revenue(price) {}
    //其他构造函数全部委托给上面的构造函数
    Sales_item():Sales_item("", 0, 0);
    Sales_item(std::string &book):Sales_item(book, 0, 0);
};
```

### 5.9 类成员的内部初始化（C++11）

在 C++98 标准里，只有 static const 声明的整型成员能在类内部初始化，并且初始化值必须是常量表达式。这些限制确保了初始化操作可以在编译时期进行。C++11 的基本思想是，允许非静态（non-static）数据成员在其声明处（在其所属类内部）进行初始化。这样，在运行过程中，需要初始值时构造函数可以使用这个初始值。

```cpp
 class A {
    public:
        int a = 7;
    };
```

具体参考[Non-static data member initializers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2628.html)

### 5.10 字面值常量类（C++11）

除了算术类型、指针、引用外，某些对象也可以是字面值类型，字面值类型可能含有函数 constexpr 成员函数，它们是隐式 const 的。

数据成员都是字面值的聚合类是字面值常量类，如果一个类不是聚合类，但是符合以下条件，则它也是字面值常量类：

- 数据成员都必须是字面值类型。
- 类必须至少含有一个 constexpr 构造函数。
- 如果一个数据成员含有类初始值，则内置类型成员的初始值也必须是一条常量表达式；或者如果成员属于某一个类类型，则初始值必须使用成员自己的 constexpr 构造函数。
- 类必须使用析构函数的默认定义，该成员必须负责销毁类的对象。

一个普通的类不能函数有 const 构造函数，但是字面值常量类必须提供至少一个 constexpr 构造函数，constexpr 构造函数可以声明为 default。或者要么constexpr 构造函数拥有唯一的返回语句，要么 constexpr 构造函数是空的。

```cpp
class Debug {
public:
    constexpr Debug(bool b = true): hw(b), io(b), other(b) { }

    constexpr Debug(bool h, bool i, bool o): hw(h), io(i), other(o) { }

    constexpr bool any() { return hw || io || other; }

    constexpr bool hardware() { return hw || io; }

    constexpr bool app() { return other; }

    void set_io(bool b) { io = b; }
    void set_hw(bool b) { hw = b; }
    void set_other(bool b) { hw = b; }

private:
    bool hw;    // 硬件错误，而非IO错误
    bool io;    // IO 错误
    bool other; // 其他错误
};
```

constexpr 构造函数必须初始化所有数据成员，初始值或者使用 constexpr 构造函数，或者是一条常量表达式。

constexpr 构造函数用于生成 constexpr 对象以及 constexpr 函数的参数或返回类型：

```cpp
constexpr Debug io_sub(false, true, false);//调试io
if(io_sub.any()){//等价于 if(true)
  cerr << "print appropriate error messages" << endl;
}

constexpr Debug prod(false);//无调试
if(prod.any()){//等价于 if(false)
  cerr << "print an error messages" << endl;
}
```

---
## 6 友元

### 友元机制

友元机制：允许一个类将对其非公有成员的访问权授予指定的函数或类。

友元的声明：

- 友元的声明以关键字 friend 开始。它只能出现在类定义的内部，可以出现在类中的任何地方。
- 友元不是授予友元关系的那个类的成员，所以它们不受声明出现部分的访问控制影响。
- 推荐将友元声明成组地放在类定义的开始或结尾。

哪些元素可以声明为友元：

- 友元可以是一个函数，该函数被称为友元函数
- 友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元
- 友元也可以只是其他类的成员函数

友元的访问权限：

- 类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。友元声明可以出现在类中的任何地方，
- 尽管友元函数的原型有在类的定义中出现过，**但是友元函数并不是成员函数**。友元不受它所在区域访问控制级别的约束。

示例：

```cpp
class Box {
private:
    double width;
public:
    void setWidth(double wid);
public://友元放在一起
    friend void printWidth(Box box);
    friend class Friend;
};

// 成员函数定义
void Box::setWidth(double wid) {
    width = wid;
}

// 请注意：printWidth() 不是任何类的成员函数
void printWidth(Box box) {
    /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */
    std::cout << "Width of box : " << box.width << std::endl;
}

//这是一个友元类
class Friend {
public:
    double getBoxWidth(Box box) {
        return box.width;
    }
};
```

访问友元函数：

- 友元的声明仅仅指定了访问的权限，而非一个统一意义上的函数声明（友元的声明，不是真正的声明），如果我们希望类的用户能够调用某个友元函数，那么我们就必须再友元声明之外再专门对函数进行一次声明。
- 为了使友元对类的用户可见，我们通常把友元的声明与类本身防止在同一个头文件中，这里的声明是指除了类内部的友元声明之外的独立声明。

### 使其他类的成员函数成为友元

```cpp
//先声明Box。
class Box;

class FriendMethod {
public:
    //这里只要声明，不要定义，否则无法访问Box的成员。
    void printBoxInfo(Box &box);
};

//Box定义
class Box {
  ...
public:
  friend void FriendMethod::printBoxInfo(Box &);
}

//之后再定义友元成员函数
void FriendMethod::printBoxInfo(Box &box) {
    std::cout << "box: " << box.width << std::endl;
}
```

### 友元声明与作用域

1. 类和非常有函数的声明不是必须出现在它们的友元声明之前（可以理解为声明一个友元函数时，不依赖于那个函数是否已经声明过）。当一个名字第一次出现在一个友元声明中，我们隐式地假设改名字在当前作用域是可见的。
2. 友元本身（的定义）不一定真的在当前作用域中（比如声明的友元可能在其他文件中定义）。
3. 就算在类的内部定义了该友元函数，我们也必须在类的外部提供相应函数的声明，从而使得函数可见，即使我们用声明友元的类的成员函数去调用那个友元函数，它必须是被声明过的。

```cpp
//演示友元的作用域
class FriendScope{
public:
    //可以在类中直接定义友元，但是如果想要调用该函数，还需要用普通方式再声明一次
    friend void f(){}
    FriendScope(){
        //错误的调用，f 没有被声明，导致无法编译。
        f();
    }

    void g();
    void h();
};

void FriendScope::g(){
    //错误的调用，f 没有被声明，导致无法编译。
    f();
}

void f();

void FriendScope::h(){
    f();//可以调用，因为 f 已经声明在作用域中了。
}
```

---
## 7 类的静态成员

通常，非 `static` 数据成员存在于类类型的每个对象中。不像普通的数据成员，`static` 数据成员独立于该类的任意对象而存在；每个 `static` 数据成员是与类关联的对象，并不与该类的对象相关联。

static 成员的特点：

- `static` 成员的名字是在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突。
- 可以实施封装。`static` 成员可以是私有成员，而全局对象不可以。
- `static` 成员是与特定类关联的。这种可见性可清晰地显示程序员的意图。

```cpp
class Account {
  public:
    void applyint() { amount += amount * interestRate; }
    static double rate() { return interestRate; }
    static void rate(double); // sets a new rate
  private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();
};
```

### 静态成员变量

我们可以使用 `static` 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。

可以通过作用 **范围解析运算符(域操作符)** 从类直接调用 static 成员，或者通过对象、引用或指向该类类型对象的指针间接调用。

```cpp
void useAccount(){
    Account ac1;
    Account *ac2 = &ac1;
    double rate;
    rate = ac1.rate();
    rate = ac2->rate();
    rate = Account::rate();   // 直接从类使用范围解析运算符
}
```

### 静态成员函数

如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加**范围解析运算符**`::`就可以访问。

static 函数的一些限制：

- static 函数没有 this 指针。static 成员是类的组成部分但不是任何对象的组成部分，因此，static 成员函数没有 this 指针。通过使用非 static 成员显式或隐式地引用 this 是一个编译时错误。
- static 成员函数不能被声明为 const 。因为 static 成员不是任何对象的组成部分，所以static 成员函数不能被声明为 const。毕竟，将成员函数声明为 const 就是承诺不会修改该函数所属的对象。
- static 成员函数也不能被声明为虚函数。

### 直接静态成员初始化

- `static` 数据成员可以声明为任意类型，可以是常量、引用、数组、类类型等。
- `static` 数据成员必须在类定义体的外部定义（正好一次）。不像普通数据成员。
- **static 成员不是通过类构造函数进行初始化，而是应该在定义时进行初始化**。

```cpp
class Box {
public:
    static int objectCount = 4;//不合法
};

//可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化
int Box::objectCount = 0;
```

### 特殊的整型 const static 成员

一般而言，类的 `static` 成员，像普通数据成员一样，不能在类的定义体中初始化。相反，static 数据成员通常在定义时才初始化。这个规则的一个例外是，只要初始化式是一个**常量表达式**，整型`const static`数据成员就可以在类的定义体中进行初始化：

```cpp
class Account {
public:
  static double rate() { return interestRate; }
  static void rate(double);  // sets a new rate
private:
  static const int period = 30;
  double daily_tbl[period];
};
```

## 8 复制控制

除了定义类的对象如何被初始化，类型还能通过下面技术来控制复制、赋值、移动或撤销该类型的对象时会发生的行为：

- **复制构造函数(copy contructor)**：一种特殊构造函数，具有单个形参，该形参（常用 const 修饰）是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将显式使用复制构造函数。当将该类型的对象传递给函数或函数返回该类型的对象时，将隐式使用复制构造函数。
- **拷贝赋值操作符(copy-assignment operator)**：拷贝赋值操作符可以通过指定不同类型的右操作数而重载。
- **析构函数(destructor)**：当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数。析构函数可用于释放对象时构造或在对象的生命期中所获取的资源。不管类是否定义了自己的析构函数，编译器都自动执行类中非 static 数据成员的析构函数。
- C++11 引入的 **移动构造函数(move contructor)** 和 **移动赋值操作符(move-assignment operator)**。

以上复制构造函数、移动构造函数、赋值操作符和析构函数总称为**复制控制**。编译器默认自动实现这些操作，但类也可以定义自己的版本。

### 8.1 复制构造函数

对象发生拷贝的场景：

- 定义对象时，使用了赋值运算符。
- 调用函数时使用值传参。
- 函数以值的形式返回对象。

参考下面代码，对象的两种初始化形式：

```cpp
//1：直接初始化
Sales_item myobj1("abc");
int a(5);

//2：拷贝初始化：这里首先创建了一个临时的 Sales_item 对象，然后以此来初始化 myobj。
Sales_item myobj2 = Sales_item();
int a = 5;
```

如果不主动定义这些操作，则编译器将为我们合成，一般编译器生成的版本将对对象的每个成员执行拷贝、赋值、销毁操作。

```cpp
A x(2);　　//直接初始化，调用构造函数
A y = x;　　//拷贝初始化，调用拷贝构造函数
```

#### 拷贝构造函数的作用

拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。具有单个形参，该形参（常用const修饰）是对该类类型的引用。

- 当定义一个新对象并用一个同类型的对象对它进行初始化时，将 **显式** 使用拷贝构造函数。
- 当该类型的对象传递给一个函数或从函数返回该类型的对象时，将 **隐式** 调用拷贝构造函数。

与默认构造函数一样，复制构造函数可由编译器隐式调用。复制构造函数可用于，拷贝构造函数通常用于：

- 根据另一个同类型的对象显式或隐式初始化一个对象。
- 复制一个对象，将它作为实参传给一个函数。
- 从函数返回时复制一个对象。
- 初始化顺序容器中的元素。
- 根据元素初始化式(`{}`形式)列表初始化数组元素。

参考下面代码：

```cpp
string null_book = "9-999-99999-9"; //复制初始化，首先根据 "9-999-99999-9" 创建临时的 string，然后使用复制构造函数
string dots(10, '.');               //直接初始化
string empty_copy = string();       //复制初始化，使用临时的空字符串来初始化 empty_copy
string empty_direct;                //直接初始化

iostream file1("filename");   // 直接初始化
ifstream file2 = "filename";  // 错误，复制构造函数是私有的
Sales_item item = string("9-999-99999-9");  //当 Sales_item(const string&) 构造函数不是 explicit 时正确

//返回一个string对象的函数，将使用复制构造函数构造返回的对象
string make_plural(size_t, const string&, const string&);

//编译器首先使用 string 默认构造函数创建一个临时值来初始化 svec，然后使用复制构造函数将临时值复制到 svec 的每个元素。
vector<string> svec(5);

//如果没有为类类型数组提供元素初始化式，则将用默认构造函数初始化每个元素。
//如果使用常规的花括号括住的数组初始化列表来提供显式元素初始化式，则使用复制初始化来初始化每个元素。

Sales_item primer_eds[] = {
      string("0-201-16487-6"),//这里根据 string 创建 Sales_item，然后使用复制构造函数初始化数组中的元素。
      string("0-201-54848-8"),
      string("0-201-82470-1"),
      Sales_item()
};
```

#### 合成复制构造函数

- 如果我们没有定义复制构造函数，编译器就会为我们合成一个。与合成的默认构造函数不同，即使我们定义了其他构造函数，也会合成复制构造函数。
- 合成复制构造函数的行为是，执行逐个成员（非static成员）初始化，将新对象初始化为原对象的副本。每个成员的类型决定了复制该成员的含义。
  - 对于内置类型成员的值，合成复制构造函数直接复制。
  - 对于类类型成员，则使用该类的复制构造函数进行复制。
  - 对于数组成员，虽然一般不能复制数组，但如果一个类具有数组成员，则合成复制构造函数将复制数组。复制数组时合成复制构造函数将复制数组的每一个元素。

#### 定义复制构造函数

如果在类中没有定义拷贝构造函数，编译器会自行定义一个，如果类带有指针变量，并有动态内存分配，则它必须有一个显式的拷贝构造函数。

拷贝构造函数的最常见形式如下：

```cpp
//复制构造函数就是接受单个类类型引用形参（通常用 const 修饰）的构造函数：
classname (const classname &obj) {
   // 构造函数的主体
}
```

复制构造函数就是接受单个const 的类类型引用形参的构造函数，虽然也可以定义接受非 const 引用的复制构造函数，但形参通常是一个 const 引用。因为用于向函数传递对象和从函数返回对象，该构造函数一般不应设置为 `explicit` 。复制构造函数应将实参的成员复制到正在构造的对象。

**定义复制构造函数最困难的部分在于认识到该类需要复制构造函数**。

#### 禁止复制

有些类需要完全禁止复制。例如 `iostream` 类就不允许复制。如果想要禁止复制，有以下方式：

- 显式将类的复制构造函数声明为 private。如果想要连友元和成员中的复制也禁止，就可以声明一个 private 的复制构造函数但不对其定义。
- 定义删除函数（C++ 11）。

#### 编译器优化

编译器可以选择性的做返回值拷贝优化，有两种优化类型：

- RVO（Return Value Optimization）:消除函数返回时创建的临时对象。
- NRVO（Named Return Value Optimization）：属于 RVO 的一种技术, 直接将要初始化的对象替代掉返回的局部对象进行操作。

### 8.2 拷贝赋值操作符

拷贝赋值操作符用于定义对类型进行复制时将会发生的动作，与复制构造函数一样，如果类没有定义自己的赋值操作符，则编译器会合成一个。当然我们也可以自定义赋值操作符，参考下面代码:

```cpp
class Book {
private:
    float price;
    std::string serialNo;

public:
    //定义构造函数
    Book(float _price, std::string &_serialNo) : price(_price), serialNo(_serialNo) {
        std::cout << "Book construct running" << std::endl;
    }

    //定义复制函构造数
    Book(const Book &book) : price(book.price), serialNo(book.serialNo) {
        std::cout << "Book copy construct running" << std::endl;
    }

    //定义拷贝操作符
    Book &operator=(const Book &book) {
        this->price = book.price;
        this->serialNo = book.serialNo;
        std::cout << "Book operator= running" << std::endl;
        return *this;
    }

};

int main() {
  string serialNo("a");

  //将调用构造函数
  Book book1(12, serialNo);
  //将调用复制构造函数
  Book book2 = book1;
  //将调用拷贝操作符
  book2 = Book(123, serialNo);

  return EXIT_SUCCESS;
}
```

- 赋值操作符必须是定义自己的类的成员。因为赋值必须是类的成员，所以 this 绑定到指向左操作数的指针。
- 赋值操作符接受单个形参，且该形参是同一类类型的对象。右操作数一般作为 const 引用传递。
- 操作符返回 `*this`，它是对左操作数对象的引用。
- 合成赋值操作符与合成复制构造函数的操作类似。它会执行逐个成员赋值：右操作数对象的每个成员赋值给左操作数对象的对应成员。除数组之外，对于数组，给每个数组元素赋值。
- 一般，如果类需要复制构造函数，则也需要赋值操作符。

### 8.3 析构函数

析构函数是构造函数的互补：当对象超出作用域或动态分配的对象被删除时，将自动调用对象的析构函数。析构函数可用于释放对象时构造或在对象的生命期中所获取的资源。不管类是否定义了自己的析构函数，编译器都自动执行类中非 `static` 数据成员的析构函数。

析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号`~`作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

- 撤销类对象时会自动调用析构函数。撤销一个容器(不管是标准库容器还是内置数组)时，也会运行容器中的类类型元素的析构函数。
- 动态分配的对象只有在指向该对象的指针被删除时才撤销。如果没有删除指向动态对象的指针，则不会运行该对象的析构函数，对象就一直存在，从而导致内存泄漏，而且，对象内部使用的任何资源也不会释放。
- 容器中的元素总是按逆序撤销：首先撤销下标为 `size() - 1` 的元素，然后是下标为 `size() - 2` 的元素…直到最后撤销下标为 0 的元素。
- 合成析构函数按对象创建时的逆序撤销每个非 static 成员，因此，它按成员在类中声明次序的逆序撤销成员。对于类类型的每个成员，合成析构函数调用该成员的析构函数来撤销对象。

许多类不需要显式析构函数，尤其是具有构造函数的类不一定需要定义自己的析构函数。仅在有些工作需要析构函数完成时，才需要析构函数。析构函数通常用于释放在构造函数或在对象生命期内获取的资源。

**如果类需要析构函数，则它也需要赋值操作符和复制构造函数，这是一个有用的经验法则。这个规则常称为三法则，指的是如果需要析构函数，则需要所有这三个复制控制成员**。

>什么时候需要定义析构函数，比如一个类含有指针成员，那么该类需要定义析构函数在对象销毁的时候去释放该指针成员。

### 8.3 管理指针成员

设计具有指针成员的类时，类设计者必须首先需要决定的是该指针应提供什么行为。将一个指针复制到另一个指针时，两个指针指向同一对象。当两个指针指向同一对象时，可能使用任一指针改变基础对象。类似地，很可能一个指针删除了一对象时，另一指针的用户还认为基础对象仍然存在。

大多数 C++ 类采用以下三种方法之一管理指针成员：

- **共享指针对象**：指针成员采取常规指针型行为。这样的类具有指针的所有缺陷但无需特殊的复制控制，可能会出现悬停指针。
- **智能指针**：类可以实现所谓的“智能指针”行为，指针所指向的对象是共享的，但类能够防止悬垂指针。
- **值复制**：类采取值型行为。指针所指向的对象是唯一的，由每个类对象独立管理。

定义智能指针的通用技术是采用一个使用计数。智能指针类将一个计数器与类指向的对象相关联。使用计数跟踪该类有多少个对象共享同一指针。使用计数为 0 时，删除对象。使用计数有时也称为引用计数。

- [] todo

### 8.4 对象移动（C++ 11）

C++ 11 新增了对象移动的特性。

>对象移动理解：对象移动可以理解为移交一些临时变量的所有权，在程序中一些变量的生存期非常短，比如部分表达式产生的值，后增运算符 i++，函数返回值等等，而我们可以在它们即将销毁之前把它们的所有权“移动”（转移）给其他变量，它们在内存中的位置是不变的，也就是没有创建新的对对象，只不过归属于其他变量了，生存期也就随着所属的变量而变化了。——[原文链接](https://blog.csdn.net/wwh578867817/article/details/42084887)。

对象移动针对以下情况：

1. 很多情况下都会发生对象拷贝，而有些对象拷贝后又会立马被销毁，而对象移动可以避免类似情况下资源的浪费。
2. 两外对于 IO 或者是 unique_ptr 这样的类，都保护不能被共享的资源，因此对象不能被拷贝，但是可以被移动。
3. 旧版本的容器要求保存的元素是可以拷贝的，而在新的标准下，可以用容器保存不可拷贝的元素，这要它们能被移动。

#### 8.4.1 右值引用

为了支持对象移动，C++ 引入了右值引用（rvalue reference）的概念。右值引用就是必须绑定到右值的引用。右值智能绑定到一个即将销毁的对象，因此可以自由地将一个右值引用的资源转移到另一个对象中。语法上通过 `&&` 来获取右值引用。

- 左值：一个左值表达式表示的是对象的身份。
- 右值：一个右值表达式表示的是对象的值。

为了区分，将常规引用称为左值引用，而右值引用与左值引用一样，都是一个对象的名字，但它们具有相反的绑定特性：

- 左值引用不能绑定到要求转换的表达式、字面常量、返回右值的表达式。
- 右值可以绑定这类表达式上，但是不能将一个右值引用直接绑定到一个左值上。

```cpp
    int i = 42;
    int &r = i;
    //int &&rr = i; 错误
    //int &r2 = i * 24; 错误，i * 24 是一个右值
    const int &r3 = i * 24;//可以将右值绑定到一个常量引用上
    int &&rr2 = i * 24;//可以将右值绑定到一个右值引用上
```

##### 左值持久，右值短暂

右值要么是字母常量，要么是表达式求值参加的临时对象。由于右值引用智能绑定到临时对象，可知:

- 所引用的对象将要销毁。
- 该对象没有其他用户。

这意味着**使用右值引用的代码可以自由地接管所引用对象的资源**。

##### 变量是左值

- 变量可以看作是只有一个运算对象而没有运算符的表达式。变量是持久的，直到离开作用域才会被销毁。
- 因为变量是左值，不能将一个右值引用绑定到一个右值引用类型的变量上。
- 变量表达式但是左值。

```cpp
int &&rr1 = 42;//正确，字面量是右值。
int &&rr2 = rr1;//错误，表达式 rr1 是左值。
```

##### `std::move` 函数

不能将一个右值引用绑定到一个左值上，但是可以显式地将一个左值转换为对于的右值引用类型。通过调用 `std::move` 函数来获得绑定到左值上的右值引用。

```cpp
int &&rr3 = std::move(rr1);//正确
```

move 函数定义在 `utility` 头文件中，其告诉编译器，有一个左值，但希望像右值一样使用它。需要注意，调用 move 就意味着承诺**除了对 rr1 进行赋值或者销毁它外，将不再使用它**，调用 move 后，不能对移后源对象的值作任何假设（可对对移后源对象进行赋值或销毁它，但不能使用它的值）。

使用 move 函数不必使用 using 声明，直接使用 `std::move` 即可。

#### 8.4.2 移动构造函数与移动赋值运算符

定义移动拷贝构造函数和移动赋值操作符可以让对象支持移动。移动拷贝构造函数的第一个参数是才类类型的一个引用。除了完成资源移动，移动拷贝构造函数必须保证移后源对象处于一种状态——**销毁它是无害的，一旦资源完成移动，源对象必须不应该再指向被移动的资源，这些资源的所有权都归于了新对象**。

```cpp
class MoveClass {
private:
    std::string *name_;
public:
...

    MoveClass(MoveClass &&other) noexcept : name_(other.name_) {
        //源对象必须不应该再指向被移动的资源，这些资源的所有权都归于了新对象
        other.name_ = nullptr;
        if (name_) {
            std::cout << *name_ << "  move MoveClass()" << std::endl;
        } else {
            std::cout << "move MoveClass()" << std::endl;
        }
    }

...
};
```

注意：

- 移动构造函数的形参是没有 const 的。
- 一般移动构造函数应该加上 noexcpet 标志。

##### 移动操作与标准容器库和异常

移动操作不设计内存分配，因此移动操作通常不应该抛出异常，一般应该给移动构造函数应该加上 noexcpet 标志。noexcpet 表示该函数不会抛出异常。

加上 noexcpet 的移动构造函数和移动赋值运算符可以让标准库容器更高效地工作。

- 对于没有定义移动构造函数的类类型对象 e，调用 `vector.push_back(e)` 时，将使用对象的移动构造函数。
- 对于没有加上 noexcpet 的移动构造函数的类类型对象 e，调用 `vector.push_back(e)` 时，将使用对象的拷贝构造函数。
- 对于加上 noexcpet 的移动构造函数的类类型对象 e，调用 `vector.push_back(e)` 时，将使用对象的移动构造函数。

```cpp
void sample4() {
    //使用移动构造函数
    vector<MoveClass> vector1;
    vector1.push_back(MoveClass("mc1"));

    //使用拷贝构造函数
    vector<NoMoveClass> vector3;
    vector3.push_back(NoMoveClass("nmc1"));
}
```

具体参考 《C Primer 5E》 13.6.2

##### 移动赋值操作符

- 移动赋值操作符进行析构与移动过构造函数的工作，析构是析构已有的资源。
- 如果移动赋值操作符不抛出异常，也应该加上 noexcpet。

```cpp
    MoveClass &operator=(MoveClass &&other) noexcept {
        if (this == &other) {
            return *this;
        }
        //使用已有的资源
        delete name_;
        //执行资源拷贝
        if (other.name_) {
            name_ = other.name_;
        }
        //将源对象置为可析构状态
        other.name_ = nullptr;
        return *this;
    }
```

使用

```cpp
    MoveClass moveClass1("A");
    //此时将使用移动赋值操作符
    moveClass1 = MoveClass("B");
```

##### 移动后的源对象必须可析构

对于移动后的源对象有以下要求：

- 移动后的源对象必须可析构，比如上面函数必须将执行 `other.name_ = nullptr;`，否则将影响新对象。
- 移动后的源对象本身仍有效，仍可以对其进行赋值。
- 程序不应该依赖移动后的源对象的值。

##### 合成的移动操作

只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。

什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则：

- 与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。
- 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。
- 类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。
- 类似拷贝赋值运算符，如果有类成员是 const 的或是引用，则类的移动赋值运算符被定义为删除的。

定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。

##### 如果同时定了拷贝和移动操作：移动右值、拷贝左值

如果同时定了拷贝和移动构造函数，编译器会按照普通的函数匹配规则来确定使用按个构造函数。赋值操作的情况类似。

```cpp
    MoveClass moveClass1("A");
    MoveClass moveClass2("B");
    moveClass1 = moveClass2;//moveClass2是左值，使用拷贝操作
    moveClass1 = MoveClass("C");//使用移动操作，MoveClass("C") 是右值
```

##### 如果定义了拷贝没有定义移动操作：右值也拷贝

如果定义了拷贝没有定义移动操作，编译器不会合成移动操作，在构造对象时即使实参是右值，也将被拷贝，即使我们试图通过 move 来移动右值时也是如此。

```cpp
//Foo 没有移动构造函数
class Foo{
public:
  Foo() = defualt;
  Foo(const Foo&);
}

Foo x;//默认构造函数
Foo y(x)//拷贝操作
Foo z(std::move(x))//拷贝操作
```

在对 z 进行初始化时调用了 `move(x)` 返回一个绑定到 x 的 Foo&&，Foo 的拷贝构造函数是可行的，因为我们可以将一个 `Foo&&` 转换为一个 `const Foo&`。因此, z 的初始化将使用 Foo 的拷贝构造函数。

##### 拷贝并交换赋值运算符和移动操作

相关内容参考[现代 C++ 30 讲](../04-现代C++实战/02-实现C++的智能指针.md)

##### 移动迭代器

略

##### 不要随意使用移动操作

由于一个移后源对象具有不确定的状态，对其调用 `std::move` 是危险的。当我们调用 move 时，必须绝对确认移后源对象没有其他用户，通过在类代码中小心地使用 move，可以大幅度提升性能。而如果随意在普通用户代码(与类实现代码相对)中使用移动操作，很可能导致莫名其妙的、难以查找的错误,而难以提升应用程序性能。

最佳实践：在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是安全的，才可以使用`std::move`。

#### 8.4.3 右值引用与成员函数

成员函数同样可以提供移动的版本，比如 `vector.push_back` 操作。

#### 8.4.4 三五法则

所有五个拷贝控制成员应该看作一个整体，一般如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作，这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下定义了移动构造函数和移动赋值运算符的类就可以避免问题。
