# 面向对象

---
## 1  定义类

### 类的定义

- 类声明由类名、类头（指定其类型参数、主 构造函数等）和由大括号包围的类体构成。
- 类头和类体都是可选的； 如果一个类没有类体，可以省略花括号。
-  主构造函数参数加上`var`或者`val`，则参数为实例对象的成员属性，而次构造函数是不允许的
- 类可以包含：**构造函数和初始化块、函数、属性、嵌套类和内部类、对象声明**

### 构造函数

- 在 Kotlin 中的一个类可以有一个主构造函数和一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（和可选的类型参数）后
- 主构造函数如果没有任何注解或者可见性修饰符，可以省略这个 `constructor` 关键字。
- 主构造函数如果有注解或可见性修饰符，这个 `constructor` 关键字是必需的，并且这些修饰符在它前面
- 主构造函数不能包含任何的代码。初始化的代码可以放到以 `init` 关键字作为前缀的初始化块（initializer blocks）中，`init`代码库可以有多个
- 主构造的参数可以在初始化块中使用。它们也可以在类体内声明的属性初始化器中使用
- 类也可以声明前缀有 `constructor` 的次构造函数
- 如果类有一个主构造函数，每个次构造函数需要委托给主构造函数，可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数 用 this 关键字即可
- 如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 `public`
- 如果不希望类有一个公有构造函数，需要声明一个带有非默认可见性的空的主构造函数
- 在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值。
- 一般情况下，不要声明多个从构造方法来重载和提供参数的默认值，而应该使用带默认参数的函数。

### 创建类的实例

- 创建类的实例：要创建一个类的实例，就像普通函数一样调用构造函数， Kotlin 并没有`new` 关键字。


### 伴生对象

- 伴生对象的成员可通过只使用类名作为限定符来调用
- 可以省略伴生对象的名称，在这种情况下将使用名称`companion`
- 即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且还可以实现接口
- 在JVM平台，如果使用 ``@JvmStatic、@JvmField`` 注解，可以将伴生对象的成员生成为真正的静态方法和字段
- 每个类，只能有一个伴生对象
- 伴生对象不能被子类重写

---
## 2 抽象类

- 类和其中的某些成员可以声明为 abstract。 抽象成员在本类中可以不用实现。 
- 需要注意的是，我们并不需要用 open 标注一个抽象类或者函数——因为这不言而喻

---
## 3  属性和字段

注意区分`属性、字段、方法`，在 Java 中，字段和它的访问器组合通常被称作属性。许多的框架大量使用这个概念。在Kotlin 中，属性是一个能完全替代字段和访问器函数的一等语言特性。

### 定义属性

- Kotlin的类可以有属性.属性可以用关键字var 声明为可变的，否则使用只读关键字val。
- `Getters 和 Setters`：声明一个属性的完整语法包含：`初始器（initializer）、getter 和 setter`,其初始器（initializer）、getter 和 setter 都是可选的。属性类型如果可以从初始器 （或者从其 getter 返回值，如下文所示）中推断出来，也可以省略
- 一个只读属性的语法和一个可变的属性的语法有两方面的不同：1、只读属性的用 `val`  2、只读属性不允许 `setter`
- 当访问一个属性时，其`getter`会被调用，而给一个属性赋值时，其`setter`会被调用
- 属性的`getter 和 setter`的可见性默认与属性的可见性一直，但是可以修改，比如 `var a` 的 setter 为 `private set` 表示该属性只能被方法，不能被修改

### 幕后字段

- 幕后字段：Kotlin 中类不能有字段。然而，当使用自定义访问器时，有一个幕后字段（backing field）有时是必要的。为此 Kotlin 提供了一个自动幕后字段，它可通过使用 `field` 标识符访问。
- 如果属性至少有一个访问器使用默认实现，或者自定义访问器通过 field 引用幕后字段，将会为该属性生成一个幕后字段。
- 幕后属性：如果你的需求不符合这套`隐式的幕后字段`方案，那么总可以使用幕后属性（backing property）

```kotlin
private class BackingField {

    // 此初始器值直接写入到幕后字段
    var counter = 0
        set(value) {
            if (value >= 0)
                field = value//field表示counter，field标识符只能用在属性的访问器内。
        }

    //既然字段和属性的差别主要是可见性，那么其实我们完全可以自己实现字段，也即幕后属性。
    //幕后属性：这里 _table 就是我们实现的“字段”，也叫幕后属性
    private var _table: Map<String, Int>? = null

    val table: Map<String, Int>
        get() {
            if (_table == null) {
                _table = HashMap() // 类型参数已推断出
            }
            return _table ?: throw AssertionError("Set to null by another thread")
        }
}
```

有支持字段和没有支持字段的属性有什么区别：访问属性的方式不依赖于它是否含有支持字段，如果你显示的引用或使用默认的访问器实现，编译器会为属性生成字段(Java中的字段)，如果你提供了一个自定义的访问器实现，并且没有使用 `field`，支持字段将不会被呈现出来。

```kotlin
//添加了自定义访问器并且没有使用field
private class Test {

    var custom: String
        get() {
            return "A"
        }
        set(value) {

        }
}
//在反编译后发现没有为 custom 生成 Java 字段
final class TestLateinit {

   @NotNull
   public final String getCustom() {
      return "A";
   }

   public final void setCustom(@NotNull String value) {
      Intrinsics.checkParameterIsNotNull(value, "value");
   }
}
```


### 编译期常量

已知值的属性可以使用 const 修饰符标记为编译期常量。编译期常量需要满足以下要求：

- 位于顶层或者是 object 的一个成员
- 用String或原生类型值初始化
- 没有自定义 getter

### 延迟初始化属性

-  一般地，属性声明为非空类型必须在构造函数中初始化。可以用 `lateinit` 修饰符标记该属性来实现延迟初始化
- `lateinit`修饰符只能用于在类体中（不是在主构造函数中）声明的 var 属性，并且仅当该属性没有自定义 `getter`或 `setter` 时。该属性必须是非空类型，并且不能是原生类型。
- 在初始化前访问一个 `lateinit` 属性会抛出一个特定异常，该异常明确标识该属性 被访问及它没有初始化的事实。

---
## 4 接口

- 定义接口：Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。
- 接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。
- 一个类或者对象可以实现一个或多个接口。
- 可以在接口中定义属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现。在接口中声明的属性不能有幕后字段（backing field），因此接口中声明的访问器不能引用它们。
- Kotlin1.0 是以 Java6 为目标设计的，其并不支持 Java 接口中的默认方法

---
## 5 可见性修饰符

类、对象、接口、构造函数、方法、属性和它们的 setter 都可以有可见性修饰符。 （getter 总是与属性有着相同的可见性。）在 Kotlin 中有这四个可见性修饰符：`private、 protected、 internal 和 public`。 如果没有显式指定修饰符的话，默认可见性是 public，internal指定的可见性作用于模块间，一个模块是编译在一起的一套 Kotlin 文件。

可见性规则：包名内

- 函数、属性和类、对象和接口可以在顶层声明，即直接在包内
- 如果声明为 `private`，只会在声明它的文件内可见
- 如果声明为 `internal`，在相同模块内随处可见
- `protected` 不适用于顶层声明
- Java 中，`internal` 类表现为 public

可见性规则：类和接口

- `private`： 意味着只在这个类内部（包含其所有成员）可见
- `protected`： 和 `private`一样，但在子类中可见，kotlin 中 protected 不具有包可见性
- `interna`：能见到类声明的本模块内的任何客户端都可见其internal 成员
- `public`： 能见到类声明的任何客户端都可见其 public 成员。

可见性规则：构造函数

- `class C private constructor(a: Int) { …… }`这里的构造函数是私有的。
-  默认情况下，所有构造函数都是 `public`，这实际上 等于类可见的地方它就可见（即 一个 `internal` 类的构造函数只能 在相同模块内可见).

模块：可见性修饰符 internal 意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译在一起的一套 Kotlin 文件：

- 一个 IntelliJ IDEA 模块
- 一个 Maven 或者 Gradle 项目

---
## 6  继承

- 在 Kotlin 中所有类都有一个共同的超类 **Any**，这对于没有超类型声明的类是默认超类
- Any 不是 `java.lang.Object`；尤其是，它除了 `equals()、hashCode()和toString()`外没有任何成员
- 要声明一个显式的超类型，需要把类型放到类头的`:`之后
- 如果基类有一个主构造函数，其基类型必须用基类型的主构造函数参数就地初始化。
- 如果基类没有主构造函数，那么每个次构造函数必须 使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。
- 类上的 `open` 标注与 Java 中 `final` 相反，它允许其他类 从这个类继承。默认情况下，在 Kotlin 中所有的类都是 `final`
- Kotlin 需要显式标注可覆盖的成员（称之为开放）和覆盖后的成员
- 子类的函数上必须加上 `override`标注。如果没写，编译器将会报错
- 如果函数没有标注 `open`，则子类中不允许定义相同签名的函数， 不论加不加 `override`。
- 在一个 `final` 类中（没有用 open 标注的类），开放成员是禁止的
- 属性覆盖与方法覆盖类似：在超类中声明然后在派生类中重新声明的属性必须以 `override` 开头，并且它们必须具有兼容的类型。
- 每个声明的属性可以由具有初始化器的属性或者具有 `getter` 方法的属性覆盖。
- 可以用一个 `var` 属性覆盖一个 `val` 属性，但反之则不行。这是允许的，因为一个 `val` 属性本质上声明了一个`getter` 方法，而将其覆盖为 var 只是在子类中额外声明一个 setter 方法
- 可以在主构造函数中使用 `override` 关键字作为属性声明的一部分。
- 如果一个类从它的直接超类继承相同成员的多个实现，它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的` super`，如 `super<Base>`
- 对有默认参数的方法加上`@JvmOverloads`，Java 代码会将其识别为方法重载
- override 的字段和方法默认是 open 的，可以显式的加上 final 来关闭 open

---
## 7 数据类：DataClass

   - 创建一些只保存数据的类。在这些类中，一些标准函数往往是从 数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为` data`
   - 编译器自动从主构造函数中声明的所有属性导出这些成员：` equals()/hashCode()`, `toString()`, `componentN()`, `copy()`，而使用`==`运算即可调用 equals 方法
   - 如果这些函数中的任何一个在类体中显式定义或继承自其基类型，则不会生成该函数

数据类的要求：为了确保生成的代码的一致性和有意义的行为，数据类必须满足以下要求

- 主构造函数需要至少有一个参数；
- 主构造函数的所有参数需要标记为 val 或 var；
- 数据类不能是抽象、开放、密封或者内部的；
- 在kotlin1.1之前，数据类只能实现接口。

---
## 8  密封类 SealedClass 与枚举

- 枚举类：枚举类的最基本的用法是实现类型安全的枚举，对应的是**实例可数**
- 密封类用来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型时。
- 在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。所以密封类对应的是**子类可数**
- 要声明一个密封类，需要在类名前面添加 `sealed` 修饰符
- 虽然密封类也可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明
- 扩展密封类子类的类（间接继承者）可以放在任何位置，而无需在 同一个文件中
- 使用密封类的关键好处在于使用 `when` 表达式 的时候，如果能够 验证语句覆盖了所有情况，就不需要为该语句再添加一个 `else` 子句了

---
## 9 嵌套类与内部类

- 内部类： `inner`标识类为内部类，内部类能够访问外部类的成员。内部类会带有一个对外部类的对象的引用，此时必须使用外部类对象才能创建内部类对象
- 内部类外部类访问完整语法：访问外部 `this@Outer.x`，访问内部 `this@Inner.x`
- 在 Kotlin 中，**外部类不能访问内部类的私有字段和方法**
- 嵌套类：如果内部类不加上`inner`修饰，那么这个内部类的行为类似 Java 中的静态内部类，这时它这是一个嵌套类
- **为什么默认是嵌套类**，而不是内部类，内部类具有更强的耦合性，比如由于内部类在持有外部类的引用，所以如果一个内部类是可以序列化的，其外部类也应该是序列化的，因为内部类在进行序列化时，也会对外部类进行序列化，如果外部类不支持序列化，则会抛出`java.io.NotSerializableException`


---
## 10 object：对象声明、对象表达式、匿名内部类

有时候，我们需要创建一个对某个类做了轻微改动的类的对象，而不用为之显式声明新的子类Java 用匿名内部类处理这种情况。 Kotlin 用对象表达式和对象声明对这个概念稍微概括了下

### 对象表达式、 匿名内部类与 SAM 构造器

要创建一个继承自某个（或某些）类型的匿名类的对象，参考下面代码：

```kotlin
    //设置一个监听器
    val window: Window = Window(Frame())
    window.addMouseListener(object : MouseAdapter() {
        override fun mouseClicked(e: MouseEvent) {
        }

        override fun mouseEntered(e: MouseEvent) {
        }
    })

    //任何时候，如果我们只需要“一个对象而已”，并不需要特殊超类型
    val adHoc = object {
        var x: Int = 0
        var y: Int = 0
    }
    print(adHoc.x + adHoc.y)

    //如果对象是函数式 Java 接口（即具有单个抽象方法的 Java 接口，）的实例， 可以使用带接口类型前缀的lambda表达式创建它，这其实是 Kotlin 提供的 SAM 构造器
    val listener = ActionListener { println("clicked") }

    val com = object : Closeable {
        override fun close() {
        }
    }
```

- 如果超类型有一个构造函数，则必须传递适当的构造函数参数给它。 多个超类型可以由跟在`:`后面的逗号分隔的列表指定
- 匿名内部类：使用**对象表达式**创建匿名内部类实例，关键字为`object`
- 如果对象是函数式Java接口（即具有单个抽象方法的 Java 接口，简称 SAM）的实例， 可以使用带接口类型前缀的lambda表达式创建它` val listener = ActionListener { println("clicked") }`
- 匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的返回类型或者用作公有属性的类型，那么该函数或属性的实际类型会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。
- 在匿名对象中添加的成员将无法被访问。
- 实现多个接口：`object:A,B,B{ ... }`，kotlin的匿名内部类可以实现多个接口
- **SAM构造函数**：一个由编译器生成的函数。它能让你显式的把 lambda 字面值转换为函数式接口。SAM 即 `Single Abstract Method`

### 对象声明

对象声明不能在**局部作用域（即直接嵌套在函数内部）**，但是它们可以嵌套到其他对象声明或非内部类中。对象声明可作为对单例模式应用。

如果一个对象需要与注入框架配合使用(比如 Dagger)，那么对象声明可能不适用于此，因为对象声明的创建是不受开发者控制的。

```kotlin
private interface DataProvider

//这是一个单利
private object DataProviderManager {

    fun registerDataProvider(provider: DataProvider) {

    }

    val allDataProviders: Collection<DataProvider>
        get() = Collections.emptyList()
}
```

### 对象表达式和对象声明之间的语义差异

- 对象表达式是在使用他们的地方立即执行（及初始化）的
- 对象声明是在第一次被访问到时延迟初始化的
- 伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配
