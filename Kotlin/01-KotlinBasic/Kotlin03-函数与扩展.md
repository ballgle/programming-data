#  函数与扩展

---
## 1 函数及其特性

- **fun** 用于函数声明，表示 kotlin 是有趣的
- **默认参数**：参数可以有默认值，Java 中没有默认参数的概念，所以 Java 调用 Kotlin 的默认参数方法时，默认参数将被忽略，可以在含有默认参数的方法上添加 `@JvmOverloads`注解，让编译器生成方法重载
- **命名参数**：传入参数时可以指定参数名。调用 Java 函数时不能使用命名参数语法，因为 Java 字节码并不总是保留函数参数的名称（把参数名保存到 class 中是 Java8 及其更高版本的一个可选功能，而 Kotlin 需要保持和 Java6 的兼容性）
- 返回 Unit 的函数：如果一个函数不返回任何有用的值，它的返回类型是 Unit。Unit 是一种只有一个值——Unit 的类型。这个值不需要显式返回
- **可变数量的参数**：函数的参数（通常是最后一个）可以用 `vararg` 修饰符标记
- 可变参数不能直接接收数组类型，使用 `*` 可以展开数组，这里 `*`称作展开运算符
- 因为有了具名参数，所以变长参数不必须在参数的最后位置
- **函数作用域**：`局部函数、 成员函数、顶层函数`
- **函数的类型**：即`函数的参数列表+返回值类型`，比如`(Int,Int)->Unit`
- `::` 函数引用
- 函数是代码块，在 Kotlin 中函数可以赋值给一个变量

---
## 2 单表达式函数

- 当函数返回单个表达式时，可以省略花括号并且在` = `符号之后指定代码体即可
- 当返回值类型可由编译器推断时，显式声明返回类型是可选的
- 有块代码体的函数必须始终显式指定返回类型

---
## 3 尾递归（TailRecursive）函数优化

- 当一个函数用 `tailrec` 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本。
- 要符合 `tailrec` 修饰符的条件的话，函数必须将其自身调用作为它执行的最后一个操作。在递归调用后有更多代码时，不能使用尾递归，
- 不能用在 `try/catch/finally` 块中使用尾递归。目前尾部递归只在 JVM 后端中支持。

---
## 4 函数扩展 与 属性扩展

- Kotlin 同 C# 类似，能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式
- 扩展一个类的新功能通过叫做扩展的特殊声明完成。Kotlin 支持扩展函数 和 扩展属性。
- 扩展也可以用于 `companion object`
- 被添加扩展函数的类被称作`接收者类型`，用来调用这个扩展函数的对象叫做`接收者对象`

扩展的写法：
```kotlin
    //方式1：
    fun Int.add(value: Int): Int {
        return this + value
    }
    println(5.add(5))

    //方式2：
    val subtract = fun Int.(value: Int): Int {
        return this - value
    }
    println(10.subtract(20))

    //属性扩展
    val <T> List<T>.lastIndex: Int
    get() = size - 1//扩展属性只有setter
```

 扩展说明:

- **扩展是静态的**：扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。
- **扩展函数是静态分发的**：即它们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的
-  **成员优先级更高**：如果一个类定义有一个成员函数和一个扩展函数，而这两个函数又有相同的接收者类型、相同的名字 并且都适用给定的参数，这种情况总是取成员函数。
- **可空接收者**：可以为可空的接收者类型定义扩展。这样的扩展可以在对象变量上调用， 即使其值为 null，
- **扩展属性**：和函数类似，Kotlin 支持扩展属性
- 由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就是为什么扩展属性不能有初始化器。它们的行为只能由显式提供的 `getters/setters` 定义
- **扩展声明为成员**：在一个类内部可以为另一个类声明扩展。在这样的扩展内部，有多个 隐式接收者 —— 其中的对象成员可以无需通过限定符访问。
- 扩展声明所在的类的实例称为**分发接收者**
- 扩展方法调用所在的接收者类型的实例称为**扩展接收者**
- 对于分发接收者和扩展接收者的成员名字冲突的情况，扩展接收者优先。要引用分发接收者的成员你可以使用限定的this语法。
- **扩展的作用域**：要使用所定义包之外的一个扩展，我们需要在调用方导入它
- **在Java中使用扩展**：扩展函数定义在 `*Kt.java` 中，`*` 表示定义扩展的 Kotlin 文件名

---
## 5 属性扩展与代理

扩展属性也可以和代理一起工作，通过反编译你会发现，属性扩展是使用静态实现的，所以一般不要这么做，除非你允许多个对象共享一个扩展属性：

```kotlin
private val LifecycleOwner.lifecycleProvider by Delegate()
```