# [《趣谈 Linux 系统》](https://time.geekbang.org/column/article/87111) 主要知识点整理

对于服务器端，Unix-Like OS 占的比例近 70%，Android 内核基于 Linux，在编程世界中，Linux 就是主流，不会 Linux 你就会格格不入。

## 零、入门准备篇

### 1 带着问题去学习

![it00_questions1](images/it00_questions1.jfif)
![it00_questions2](images/it00_questions2.jfif)
![it00_questions3](images/it00_questions3.jfif)
![it00_questions4](images/it00_questions4.jfif)

### 2 学习 Linux 的 6 个阶段

1. 抛弃旧的思维习惯，熟练使用 Linux 命令行，从 Windows 的思维习惯，切换成 Linux 的“命令行 + 文件”使用模式。
   1. 《鸟哥的 Linux 私房菜》
   2. 《Linux 系统管理技术手册》
2. 通过系统调用或者 glibc，学会自己进行程序设计。
   1. 《UNIX 环境高级编程》
3. 了解 Linux 内核机制，反复研习重点突破
   1. 《深入理解 LINUX 内核》
4. 阅读 Linux 内核代码，聚焦核心逻辑和场景
   1. 《LINUX 内核源代码情景分析》
5. 实验定制化 Linux 组件
6. 面向真实场景的开发

![it00_steps](images/it00_steps.jfif)

相关学习资料：

- 第一步：
  - [别出心裁的Linux命令学习法](https://www.cnblogs.com/rocedu/p/4902411.html)
- 第二步：
  - 先读《Unix/Linux编程实践教程》，再读 《UNIX 环境高级编程》。
  - [别出心裁的Linux系统调用学习法](https://www.cnblogs.com/rocedu/p/6016880.html)
- 第三步：
  - 《庖丁解牛Linux内核分析》

## 一、核心原理篇：第一部分 Linux操作系统综述

### 1 把Linux内核当成一家软件外包公司的老板

操作系统其实就像一个软件外包公司，其内核就相当于这家外包公司的老板。

- **计算机硬件**：包括 CPU、主板、网卡、显卡、硬盘、鼠标、键盘、显示器等，但是光有这些还不够，还需要操作系统。
- 操作系统究竟是如何把这么多套复杂的东西管理起来？这其中包括：
  - **文件管理子系统**：硬盘是个物理设备，要按照规定格式化成为文件系统，才能存放这些程序。文件系统需要一个系统进行统一管理，称为文件管理子系统（File Management Subsystem）。
  - **系统调用**：打印机的直接操作是放在操作系统内核里面的，进程不能随便操作。但是操作系统也提供一个办事大厅，也就是系统调用（System Call）。
  - **进程管理子系统**：在操作系统中，进程的执行也需要分配 CPU 进行执行，也就是按照程序里面的二进制代码一行一行地执行。于是，为了管理进程，我们还需要一个进程管理子系统（Process Management Subsystem）。如果运行的进程很多，则一个 CPU 会并发运行多个进程，也就需要 CPU 的调度能力了。
  - **内存管理子系统**：在操作系统中，不同的进程有不同的内存空间，但是整个电脑内存就这么点儿，所以需要统一的管理和分配，这就需要内存管理子系统（Memory Management Subsystem）。
- 程序的的二进制文件是静态的，称为程序（Program），而运行起来的程序，是不断进行的，称为进程（Process）。

外包公司与操作系统对应理解：

![subsystem](images/it01-os-subsystem.jfif)

操作系统全貌：

![subsystem](images/it01-whole-subsystem.jfif)

### 2 命令行

![it02-command](images/it02-command.jfif)

### 3 系统调用

1. **进程管理**
   1. 创建进程的系统调用叫 `fork`
   2. 要创建一个新的进程，需要一个老的进程调用 fork 来实现，其中老的进程叫作父进程（Parent Process），新的进程叫作子进程（Child Process）。
   3. 当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。
   4. fork 函数有返回值，可以根据返回值区分接下来的流程是属于子进程的还是父进程的，比如 0 就代表当前进程是父进程。如果子进程想要执行另外的程序，可以调用 execve 函数族，这样子进程和父进程就彻底分开了。
   5. waitpid 调用用于让父进程等待子进程，父进程调用该函数，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。
2. **内存管理**
   1. 在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间。
   2. 进程内存空间包含代码端和数据段。
      1. 代码段用于存分程序代码。
      2. 数据段用于存储程序运行所产生的数据，又包括堆和栈。
   3. 在堆里面分配内存的系统调用：brk 和 mmap：
      1. 当分配的内存数量比较小的时候，使用 `brk`，会和原来的堆的数据连在一起。
      2. 当分配的内存数量比较大的时候，使用 `mmap`，会重新划分一块区域。
3. **文件管理**：Linux 里面一切皆文件。
   1. 程序是二进制文件。
   2. 一些配置文件为文本文件。
   3. 标准输出 stdin、stdout 也是文件。
   4. 管道也是文件。
   5. Socket 是文件。
   6. 设备也是文件。
   7. 文件夹也是文件。
   8. 进程运行起来，要想看到进程运行的情况，会在 /proc 下面有对应的进程号，也是一系列文件。
4. **项目异常处理与信号处理**
   1. 当程序遇到异常时，会收到信号（Signal）。信号产生的情况可能是：
      1. 在键盘输入“CTRL+C”，这就是中断的信号。
      2. 非法访问内存。
      3. 硬件故障。
      4. 用户进程通过kill函数，将一个用户信号发送给另一个进程。
   2. 信号的处理，有些信号不严重，可以忽略不处理，有些信号表示遇到了不可恢复的异常，比如 SIGKILL（用于终止一个进程的信号）和 SIGSTOP（用于中止一个进程的信号）。
      1. 每个信号都有默认的处理动作，比如硬件异常信号的默认处理就是终止程序。
      2. 也可以通过 `sigaction` 系统调用注册信号处理函数。
5. **进程间通信**
   1. 进程间可以通过消息队列（Message Queue）进行通信，消息队列运行在内核中。
      1. msgget 调用用于创建一个新的队列。
      2. msgsnd 调用用于将消息发送到消息队列。
      3. msgrcv调用用于接收方从队列中取消息。
   2. 共享内存：用于进程间通信时信息量比较大的情况。
      1. shmget 用于创建一个共享内存块。
      2. shmat 用于将共享内存映射到自己的内存空间，然后就可以读写了。
   3. 共享内存安全，既然是共享就存在着并发安全问题，Semaphore 用于包装内存安全。
      1. sem_wait 用于尝试获取信号量。
      2. sem_post 用于释放信号量。
6. **网络通信**：网络服务是通过套接字 Socket 来提供服务的。Socket 理解为“插口”或者“插槽”讲。虽然我们是写软件程序，但是你可以想象成弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。因此，在通信之前，双方都要建立一个 Socket。
7. **Glibc** 函数库
   1. Glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。Glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。
   2. 直接使用系统调用可能比较负责，我们可以通过 Glibc 进行间接调用，其提供了很多系统调用的封装，每个特定的系统调用对应了至少一个 Glibc 封装的库函数。
      1. sys_open 对应 Glibc 的 open。
      2. Glibc 的 print 用到了 sys_open、sys_mmap、sys_write、sys_close 系统调用。
      3. Glibc 的 malloc、calloc、free 都基于 sys_brk 系统调用实现。

扩展：

1. Linux 内核源码中，unistd_64.h 文件，里面对于系统调用的定义。
2. 命令 strace 常用来跟踪进程执行时系统调用和所接收的信号。可以尝试使用它查看一些命令行都执行了哪些系统调用。

![it3-sys-call](images/it3-sys-call.jfif)

## 二、核心原理篇：第二部分 系统初始化

### 1 x86 架构

1 **计算机工作模式**：

1. 计算机硬件：
   1. CPU（Central Processing Unit，中央处理器）。这是这台计算机的大脑，所有的设备都围绕它展开。
   2. 总线（Bus）：链接 CPU 和其他设备的设备，实际上就是主板上密密麻麻的集成电路。当然总线上还有一些其他设备，例如显卡会连接显示器、磁盘控制器会连接硬盘、USB 控制器会连接键盘和鼠标等等
   3. 内存（Memory）：用来存储 CPU 计算时产生的临时的中间数据。
   4. ![it4-computer-hardware](images/it4-computer-hardware.jfif)
2. **CPU 工作模式**：
   1. CPU 包括三个单元：
      1. 运行单元：负责运算。
      2. 数据单元：包括 CPU 内部的缓存和寄存器组，空间很小，但是速度飞快，可以暂时存放数据和运算结果。
      3. 控制单元：控制单元是一个统一的指挥中心，它可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。
   2. 当程序运行起来就会生成进程，每个进程都有自己独立的内存空间，互相隔离。进程的内存控件整体上包括代码段和数据段。
   3. CPU 如果执行程序和操作进程内存控件的数据？
      1. CPU 的控制单元里面，有一个指令指针寄存器，它里面存放的是下一条指令在内存中的地址。控制单元会不停地将代码段的指令拿进来，先放入指令寄存器。
      2. 每条指令包括两个部分：一部分时当前指令做什么操作（比如加减乘除）；一部分时操作的数据。
      3. 执行的过程为：第一部分交给运算单元，第二部分交给数据单元。数据单元根据地址从内存中拿到数据，然后运算单元开始执行操作，操作后的结果会暂存寄存器，最终通过指令将结果写回到主存中。（不一定是即时的）
   4. **进程切换**：CPU 里有两个寄存器，专门保存当前处理进程的代码段的起始地址，以及数据段的起始地址。当某个进程指令执行完毕，就可能切换到另一个进程。
   5. ![it4-cpu-interacti-memory](images/it4-cpu-interacti-memory.jfif)
3. **总线**上主要有两类数据，一类是地址数据；一类是真实的数据。
   1. 地址总线（Address Bus）用于传输地址数据。地址总线的位数，决定了能访问的地址范围到底有多广。例如只有两位，那 CPU 就只能认 00，01，10，11 四个位置，超过四个位置，就区分不出来了。
   2. 数据总线（Data Bus）用于传输真是数据。数据总线的位数，决定了一次能拿多少个数据进来。例如只有两位，那 CPU 一次只能从内存拿两位数。要想拿八位，就要拿四次。

2 **x86 标准历史**：

1. IBM 开始做 IBM PC 时，采用了英特尔的 8088 芯片作为 CPU，使用微软的 MS-DOS 做操作系统。因为卖得太好导致其他公司没有市场而被起诉垄断，后面 IBM 公开了一些相关技术，后面这些技术逐渐形成了行业标准，由于这个系列开端于 8086，因此称为 x86 架构。
2. 后期英特尔的 CPU 数据总线和地址总线越来越宽，处理能力越来越强，但是实战坚持着三个原则：一是标准，二是开放，三是兼容。
3. ![it4-x86.jfif](images/it4-x86.jfif)

3 **8086 CPU 原理**：

- [ ] todo

4 **32 位处理器**

- [ ] todo

相关资料：

- 网易云课堂上：《汇编从零开始到C语言》
- [Guide to x86 Assembly](http://www.cs.virginia.edu/~evans/cs216/guides/x86.html)

### 2 从 BIOS 到 bootloader

- [ ] todo

### 3 内核初始化

- [ ] todo

### 4 系统调用

- [ ] todo
