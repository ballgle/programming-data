# 操作系统与编程语言相关概念

>刚开始接触计算机与编程时，对学习过程中出现的一些名词感到非常陌生，于是便决定整理和收集相关名词的基本概念。

---
## 操作系统

操作系统（英语：operating system，缩写：OS）是 **管理计算机硬件与软件资源的计算机程序**，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出装置、操作网络与管理文件系统等基本事务。操作系统也提供一个让使用者与系统互动的操作界面。

---
## UNIX

UNIX操作系统，是一个强大的**多用户、多任务操作系统，支持多种处理器架构**，按照操作系统的分类，属于 **分时操作系统**，最早由KenThompson、Dennis Ritchie和Douglas McIlroy于1969年在AT&T的贝尔实验室开发。目前它的商标权由国际开放标准组织所拥有，只有符合单一UNIX规范的UNIX系统才能使用UNIX这个名称，否则只能称为类UNIX（UNIX-like）。

### UNIX的特性

- UNIX系统是一个多用户，多任务的分时操作系统。
- UNIX的系统结构可分为三部分：操作系统内核（是UNIX系统核心管理和控制中心，在系- 统启动或常驻内存），系统调用（供程序开发者开发应用程序时调用系统组件，包括进程- 管理，文件管理，设备状态等），应用程序（包括各种开发工具，编译器，网络通讯处理- 程序等，所有应用程序都在Shell的管理和控制下为用户服务）。
- UNIX系统大部分是由C语言编写的，这使得系统易读，易修改，易移植。
- UNIX提供了丰富的，精心挑选的系统调用，整个系统的实现十分紧凑，简洁。
- UNIX提供了功能强大的可编程的Shell语言（外壳语言）作为用户界面具有简洁，高效的特点。
- UNIX系统采用树状目录结构，具有良好的安全性，保密性和可维护性。
- UNIX系统采用进程对换（Swapping）的内存管理机制和请求调页的存储方式，实现了虚拟内存管理，大大提高了内存的使用效率。
- UNIX系统提供多种通信机制，如：管道通信，软中断通信，消息通信，共享存储器通信，信号灯通信。

### UNIX标准

UNIX用户协会最早从20世纪80年代开始标准化工作，1984年颁布了试用标准。后来IEEE为此制定了 **POSIX**标准（即IEEE1003标准）国际标准名称为ISO/IEC9945.它通过一组最小的功能 **定义了在UNIX操作系统和应用程序之间兼容的语言接口**。POSIX是由Richard Stallman 应IEEE的要求而提议的一个易于记忆的名称，含义是`Portable OPerating System Interface`（可移植操作系统接口） ，而X表明其API的传承，**Mac OS基于Unix开发**。

---
## POSIX

POSIX表示可移植操作系统接口（Portable Operating System Interface ，缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提供的接口标准，是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。

POSIX标准意在期望获得源代码级别的软件可移植性。换句话说，为一个POSIX兼容的操作系统编写的程序，应该可以在任何其它的POSIX操作系统（即使是来自另一个厂商）上编译执行。

POSIX 并不局限于 UNIX。许多其它的操作系统，例如 DEC OpenVMS 支持 POSIX 标准，尤其是 IEEE Std. 1003.1-1990（1995 年修订）或 POSIX.1，POSIX.1 提供了源代码级别的 C 语言应用编程接口（API）给操作系统的服务程序，例如读写文件。POSIX.1 已经被国际标准化组织（International Standards Organization，ISO）所接受，被命名为 ISO/IEC 9945-1:1990 标准。

- Windows 8.1 时候已经移除了POSIX子系统

---
## Linux

Linux是一套免费使用和自由传播的类Unix操作系统，是一个 **基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统**。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。

Linux操作系统诞生于1991 年10 月5 日（这是第一次正式向外公布时间）。Linux存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。
严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了 **用Linux来形容整个基于Linux内核，并且使用GNU工程各种工具和数据库的操作系统**。

>Linux基于Minix，Torvalds利⽤GNU的bash当做开发环境，gcc当做编译⼯具，编写了Linux内核-v0.02，但是⼀开始Linux并不能兼容Unix，即Unix上跑的应⽤程序不能在Linux上跑，即应⽤程序与内核之间的接⼝不⼀致，因为Unix是遵循POSIX规范的，因此Torvalds修改了Linux，并遵循POSIX（Portable OperatingSystem Interface，他规范了应⽤程序与内核的接⼝规范）；⼀开始Linux只适⽤于x86，后来经过全世界的⽹友的帮助，最终能够兼容多种硬件；

---
## GNU

GNU计划，又称革奴计划，是由Richard Stallman(理查德 斯托曼)在1983年9月27日公开发起的。**它的目标是创建一套完全自由的操作系统**。Richard Stallman最早是在net.unix-wizards新闻组上公布该消息，并附带《GNU宣言》等解释为何发起该计划的文章，其中一个理由就是要“重现当年软件界合作互助的团结精神”。为保证GNU软件可以自由地“使用、复制、修改和发布”，所有GNU软件都有一份在禁止其他人添加任何限制的情况下授权所有权利给任何人的协议条款，GNU通用公共许可证（GNU General Public License，GPL）。即“反版权”（或称Copyleft）概念。

**GNU是“GNU is Not Unix”的递归缩写**，**GNU是一个自由操作系统**，其内容软件完全以GPL方式发布。这个操作系统是GNU计划的主要目标，名称来自GNU's Not Unix!的递归缩写，因为GNU的设计类似Unix，但它不包含具著作权的Unix代码。GNU的创始人，理察·马修·斯托曼，将GNU视为“达成社会目的技术方法”。

作为操作系统，**GNU的发展仍未完成**，其中最大的问题是具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，是自由软件基金会发展的重点，但是其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。Linux操作系统包涵了Linux内核与其他自由软件项目中的GNU组件和软件，可以被称为GNU/Linux（见GNU/Linux命名争议）。

1991年Linus Torvalds编写出了与UNIX兼容的Linux操作系统内核并在GPL条款下发布。Linux之后在网上广泛流传，许多程序员参与了开发与修改。1992年Linux与其他GNU软件结合，完全自由的操作系统正式诞生。该操作系统往往被称为“GNU/Linux”或简称Linux。（尽管如此GNU计划自己的内核Hurd依然在开发中，已经发布Beta版本。）

### gcc

GNU编译器套件（GNU Compiler Collection）包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）。GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由。

GCC（GNU Compiler Collection，GNU编译器套件），是由 GNU 开发的编程语言编译器。它是以GPL许可证所发行的自由软件，也是 GNU计划的关键部分。GCC原本作为GNU操作系统的官方编译器，现已被大多数类Unix操作系统（如Linux、BSD、Mac OS X等）采纳为标准的编译器，GCC同样适用于微软的Windows。GCC是自由软件过程发展中的著名例子，由自由软件基金会以GPL协议发布。

GCC 原名为 GNU C 语言编译器（GNU C Compiler），因为它原本只能处理 C语言。GCC 很快地扩展，变得可处理 C++。后来又扩展能够支持更多编程语言，如Fortran、Pascal、Objective-C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件（GNU Compiler Collection）

---
## Cygwin

Cygwin是许多自由软件的集合，最初由Cygnus Solutions开发，用于各种版本的Microsoft Windows上，运行类UNIX系统。Cygwin的主要目的是通过重新编译，将POSIX系统（例如Linux、BSD，以及其他Unix系统）上的软件移植到Windows上。Cygwin移植工作在Windows NT上比较好，在Windows 95和Windows 98上，相对差劲一些。目前Cygwin由Red Hat等负责维护。

Cygwin 提供一个UNIX 模拟 DLL 以及在其上层构建的多种可以在 Linux 系统中找到的软件包，在 Windows XP SP3 以上的版本提供良好的支持。Cygwin主要由Red Hat及其下属社区负责维护。

Cygwin属于Windows平台的模拟器类型软件。

---
## MinGW

MinGW（Minimalist GNU for Windows），又称mingw32，是将GCC编译器和GNU Binutils移植到Win32平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。另有可用于产生32位及64位Windows可执行文件的MinGW-w64项目，是从原本MinGW产生的分支，如今已经独立发展。

**MinGW是从Cygwin（1.3.3版）基础上发展而来**。MinGW使用Windows中的C运行库。因此用MinGW开发的程序不需要额外的第三方DLL支持就可以直接在Windows下运行，而且也不一定必须遵从GPL许可证。这同时造成了MinGW开发的程序只能使用Win32API和跨平台的第三方库，而缺少POSIX支持[3]，大多数GNU软件无法在不修改源代码的情况下用MinGW编译。

---
## make

在软件开发中，make是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。它是一种转化文件形式的工具，转换的目标称为“target”；与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。它的依赖关系检查系统非常简单，主要根据依赖文件的修改时间进行判断。大多数情况下，它被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。它使用叫做“makefile”的文件来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行。

许多现代软件的开发中(如Microsoft Visual Studio)，集成开发环境已经取代make，但是在Unix环境中，仍然有许多任务程师采用make来协助软件开发。

**版本**：make程序已被用户多次重/改写，其中包括几次用相同的文件格式和算法原理重新编写，并且依照不同需要添加了一些不常见的改良。

- `GNU make`：仿照make的标准功能（通过clean-room工程）重新改写，并加入作者觉得值得加入的新功能，常和GNU编译系统一起被使用，是大多数GNU Linux安装的一部分。
- `Microsoft nmake`：广泛应用于微软的Windows，微软的nmake是 Visual Studio 随附的命令行工具，不要与来自AT&T和贝尔实验室的Unix系统nmake混淆。

---
## 编译型语言与解释型语言

### 编译型

编译型，其实它和汇编语言是一样的：也是**有一个负责翻译的程序来对我们的源代码进行转换，生成相对应的可执行代码**。这个过程说得专业一点，就称为**编译**（Compile），而负责编译的程序自然就称为**编译器（Compiler）**。如果我们写的程序代码都包含在一个源文件中，那么通常编译之后就会直接生成一个可执行文件，我们就可以直接运行了。但对于一个比较复杂的项目，为了方便管理，我们通常把代码分散在各个源文件中，作为不同的模块来组织。这时编译各个文件时就会生成目标文件（Object   file）而不是前面说的可执行文件。一般一个源文件的编译都会对应一个目标文件。这些目标文件里的内容基本上已经是可执行代码了，但由于只是整个项目的一部分，所以我们还不能直接运行。待所有的源文件的编译都大功告成，我们就可以最后把这些半成品的目标文件“打包”成一个可执行文件了，这个工作由另一个程序负责完成，由于此过程好像是把包含可执行代码的目标文件连接装配起来，所以又称为链接（Link），而负责链接的程序就叫……就叫链接程序（Linker）。链接程序除了链接目标文件外，可能还有各种资源，像图标文件啊、声音文件啊什么的，还要负责去除目标文件之间的冗余重复代码，等等，所以……也是挺累的。链接完成之后，一般就可以得到我们想要的可执行文件了。 

### 解释型

上面我们大概地介绍了编译型语言的特点，现在再看看解释型。噢，从字面上看，“编译”和“解释”的确都有“翻译”的意思，它们的区别则在于**翻译的时机安排不大一样**。打个比方：假如你打算阅读一本外文书，而你不知道这门外语，那么你可以找一名翻译，给他足够的时间让他从头到尾把整本书翻译好，然后把书的母语版交给你阅读；或者，你也立刻让这名翻译辅助你阅读，让他一句一句给你翻译，如果你想往回看某个章节，他也得重新给你翻译。

### 区别

两种方式，前者就相当于我们刚才所说的编译型：一次把所有的代码转换成机器语言，然后写成可执行文件；而后者就相当于我们要说的解释型：在程序运行的前一刻，还只有源程序而没有可执行程序；而程序每执行到源程序的某一条指令，则会有一个称之为解释程序的外壳程序将源代码转换成二进制代码以供执行，总言之，就是不断地解释、执行、解释、执行……所以，解释型程序是离不开解释程序的。像早期的BASIC就是一门经典的解释型语言，要执行BASIC程序，就得进入BASIC环境，然后才能加载程序源文件、运行。解释型程序中，由于程序总是以源代码的形式出现，因此只要有相应的解释器，移植几乎不成问题。编译型程序虽然源代码也可以移植，但前提是必须针对不同的系统分别进行编译，对于复杂的工程来说，的确是一件不小的时间消耗，况且很可能一些细节的地方还是要修改源代码。而且，解释型程序省却了编译的步骤，修改调试也非常方便，编辑完毕之后即可立即运行，不必像编译型程序一样每次进行小小改动都要耐心等待漫长的Compiling…Linking…这样的编译链接过程。不过凡事有利有弊，由于解释型程序是将编译的过程放到执行过程中，这就决定了解释型程序注定要比编译型慢上一大截，像几百倍的速度差距也是不足为奇的。

### 利弊

编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像`C/C++、Pascal/Object   Pascal（Delphi）、VB`等基本都可视为编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如`Java、JavaScript、VBScript、Perl、Python`等等。

### Java(编译+解释)

但既然编译型与解释型各有优缺点又相互对立，所以一批新兴的语言都有把两者折衷起来的趋势，例如Java语言虽然比较接近解释型语言的特征，但在执行之前已经预先进行一次预编译，生成的代码是介于机器码和Java源代码之间的中介代码，运行的时候则由JVM（Java的虚拟机平台，可视为解释器）解释执行。它既保留了源代码的高抽象、可移植的特点，又已经完成了对源代码的大部分预编译工作，所以执行起来比“纯解释型”程序要快许多。而像VB6（或者以前版本）、C#这样的语言，虽然表面上看生成的是.exe可执行程序文件，但VB6编译之后实际生成的也是一种中介码，只不过编译器在前面安插了一段自动调用某个外部解释器的代码（该解释程序独立于用户编写的程序，存放于系统的某个DLL文件中，所有以VB6编译生成的可执行程序都要用到它），以解释执行实际的程序体。C#（以及其它.net的语言编译器）则是生成.net目标代码，实际执行时则由.net解释系统（就像JVM一样，也是一个虚拟机平台）进行执行。当然.net目标代码已经相当“低级”，比较接近机器语言了，所以仍将其视为编译语言，而且其可移植程度也没有Java号称的这么强大，Java号称是“一次编译，到处执行”，而.net则是“一次编码，到处编译”。呵呵，当然这些都是题外话了。总之，随着设计技术与硬件的不断发展，编译型与解释型两种方式的界限正在不断变得模糊。

---
## 动态语言与静态语言

通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言。

### 动态类型语言

动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。

### 静态类型语言

静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。对于动态语言与静态语言的区分，套用一句流行的话就是：Static typing when possible, dynamic typing when needed。静态语言是在编译时确定类型，而弱类型是在运行时确定类型。

---
##  强类型语言与弱类型语言

### 强类型定义语言

强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。

### 弱类型定义语言

弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的！例如：Python是动态语言，是强类型定义语言（类型安全的语言）; VBScript是动态语言，是弱类型定义语言（类型不安全的语言）; JAVA是静态语言，是强类型定义语言（类型安全的语言）。

---
## 脚本语言

脚本语言（英语：Scripting language）是为了缩短传统的“编写、编译、链接、运行”（edit-compile-link-run）过程而创建的计算机编程语言。此命名起源于一个脚本“screenplay”，每次运行都会使对话框逐字重复。早期的脚本语言经常被称为批处理语言或工作控制语言。一个脚本通常是解释运行而非编译。脚本语言通常都有简单、易学、易用的特性，目的就是希望能让程序员快速完成程序的编写工作。而宏语言则可视为脚本语言的分支，两者也有实质上的相同之处。虽然许多脚本语言都超越了计算机简单任务自动化的领域，成熟到可以编写精巧的程序，但仍然还是被称为脚本。几乎所有计算机系统的各个层次都有一种脚本语言。包括操作系统层，如计算机游戏，网络应用程序，字处理文档，网络软件等。在许多方面，高级编程语言和脚本语言之间互相交叉，二者之间没有明确的界限。

### 脚本语言起源

脚本语言是一种计算机程序语言，因此也能让开发者藉以编写出让电脑听命行事的程序。以简单的方式快速完成某些复杂的事情通常是创造脚本语言的重要原则，基于这项原则，使得脚本语言通常比C语言、C++语言或 Java之类的系统编程语言要简单容易，也让脚本语言另有一些属于脚本语言的特性：

- 语法和结构通常比较简单
- 学习和使用通常比较简单
- 通常以容易修改程序的“解释”作为运行方式，而不需要“编译”
- 程序的开发产能优于运行性能

一个脚本可以使得本来要用键盘进行的相互式操作自动化。一个Shell脚本主要由原本需要在命令行输入的命令组成，或在一个文本编辑器中，用户可以使用脚本来把一些常用的操作组合成一组序列。主要用来书写这种脚本的语言叫做脚本语言。很多脚本语言实际上已经超过简单的用户命令序列的指令，还可以编写更复杂的程序。

---
## 什么是shell

在计算机科学中，壳层（英语：shell）指“**为用户提供用户界面**”的软件，**通常指的是命令行界面的解析器**。一般来说，这个词是指操作系统中，提供访问内核所提供之服务的程序。Shell也用于泛指所有为用户提供操作界面的程序，也就是程序和用户交互的层面。因此与之相对的是程序内核，内核不提供和用户的交互功能。

不过这个词也拿来指应用软件，或是任何在特定组件外围的软件，例如浏览器或电子邮件软件是HTML排版引擎的shell。Shell这个词是来自于操作系统（内核）与用户界面的外层界面。

通常将shell分为两类：**命令行与图形界面**。

- 命令行壳层提供一个命令行界面（CLI）；
- 图形壳层提供一个图形用户界面（GUI）。

---
## 什么是批处理

批处理（Batch）通常被认为是一种简化的脚本语言，它应用于DOS和Windows系统中，它是由DOS或者Windows系统内嵌的解释器（通常是COMMAND.COM或者CMD.EXE）解释运行。类似于Unix中的Shell脚本。批处理文件具有.bat或者.cmd的扩展名，其最简单的例子，是逐行书写在命令行中会用到的各种命令。更复杂的情况，需要使用if、for、goto等命令控制程序的运行过程，如同C、Basic等高级语言一样。如果需要实现更复杂的应用，利用外部程序是必要的，这包括系统本身提供的外部命令和第三方提供的工具或者软件。批处理程序虽然是在命令行环境中运行，但不仅仅能使用命令行软件，任何当前系统下可运行的程序都可以放在批处理文件中运行。有些人认为批处理语言的含义要比上面的描述更广泛，还包括许多软件自带的批处理语言，如 Microsoft Office、Visual Studio、Adobe Photoshop 所内置的批处理语言的功能，用户可通过它们让相应的软件执行自动化操作（例如调整某个资料夹所有 PSD 图档的分辨率）。 而这类批处理语言也大多提供把一系列操作录制为批处理文件的功能，这样用户不必写程序就能得到批处理程序。

---
## 什么是语法糖

**语法糖**（Syntactic sugar），也译为糖衣**语法**，是由英国计算机科学家彼得·蘭丁发明的一个术语，指计算机语言中添加的某种**语法**，这种**语法**对语言的功能并没有影响，但是更方便程序员使用。

---
## 迭代器、迭代和循环有什么区别

迭代器（iterator）有时又称游标（cursor）是程式设计的软件设计模式，可在容器物件（container，例如链表或阵列）上遍访的界面，设计人员无需关心容器物件的内存分配的实现细节。

表示“重复”这个含义的词有很多, 比如循环(loop), 递归(recursion), 遍历(traversal), 迭代(iterate)。

- **循环** 算是最基础的概念, 凡是重复执行一段代码, 都可以称之为循环. 大部分的递归, 遍历, 迭代, 都是循环
- **递归** 是根据一种(几种)基本情况定义的算法, 其他复杂情况都可以被逐步还原为基本情况.在编程中的特征就是, 在函数定义内重复调用该函数
- **迭代(编程)** 是按顺序访问一个列表中的每一项, 在很多编程语言中表现为foreach语句
- **遍历**: 是按一定规则访问一个非线性的结构中的每一项, 强调非线性结构(树, 图). 而迭代一般适用于线性结构(数组, 队列)

---
## 并发与并行

如果某个系统支持两个或者多个动作（Action）**同时存在**，那么这个系统就是一个 **并发系统**。如果某个系统支持两个或者多个动作 **同时执行**，那么这个系统就是一个 **并行系统**。并发系统与并行系统这两个定义之间的关键差异在于 **存在** 这个词。在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。我相信你已经能够得出结论—— **并行概念是并发概念的一个子集**。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。

具体参考[连接](https://www.zhihu.com/question/33515481/answer/10534801)

---
## 透明

透明的意思就是：无论它的内部是如何实现的，它提供的对外接口是一致的，调用接口的人无需关心其内部实现原理。透明的意思是：

- 库像一块玻璃，我们看过去，却看不见这个库，而是看到了玻璃后面的东西。任何一个库都是很复杂的。
- **隐藏了内部的实现细节，库只需要给我们暴露接口**。

具体参考[透明](https://www.zhihu.com/question/39501329)

---
## 状态机

有限状态机(finite-state machine,缩写FSM)，又称有限状态自动机，简称状态机，是用于表示**有限个状态以及在这些状态之间的转移和动作等行为**的数学模型。

关键词：**有限个状态**、**状态转移**、**动作行为**、**数学模型**

- 状态存储关于过去的信息，就是说：它反映从系统开始到现在时刻的输入变化。
- 转移指示状态变更，并且用必须满足确使转移发生的条件来描述它。
- 动作是在给定时刻要进行的活动的描述。有多种类型的动作：
  - 进入动作（entry action）：在进入状态时进行
  - 退出动作：在退出状态时进行
  - 输入动作：依赖于当前状态和输入条件进行
  - 转移动作：在进行特定转移时进行

具体参考[维基百科](https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA)

---
## 闭包和Lambda表达式

维基百科：在计算机科学中，**闭包**（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。———具体参考<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">维基百科</a>

**Lambda 表达式**(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包

---
## 自顶向下

自顶向下（top-down）的分析算法通过在最左推导中描述出各个步骤来分析记号串输入。将复杂的大问题分解为相对简单的小问题，找出每个问题的关键、重点所在，然后用精确的思维定性、定量地去描述问题。其核心本质是"分解"。——《百度百科》

---
## 原码、反码、补码

- 正数：原码 = 反码 = 补码
- 负数：反码 = 符号位不变，其他位取反；补码 = 反码+1

---
## 互联网、因特网、万维网

互联网包含因特网，因特网包含万维网。

### 互联网(internet)

凡是由彼此通信的设备组成的网络就叫互联网，即使仅有两台机器（计算机、手机等），不论用何种技术使其彼此通信，都叫互联网，所以，互联网有广域网、城域网及局域网之分。国际标准的互联网写法是internet，字母i一定要小写！

### 因特网(Internet)

因特网是互联网中的一种，它可不是仅有两台机器组成的网络，而是由上千万台设备组成的网络（该网络具备一定规模）。**因特网使用TCP/IP（与UDP）协议让不同的设备可以彼此通信**。但使用TCP/IP（与UDP）协议的网络并不一定是因特网，一个局域网也可以使用TCP/IP（与UDP）协议。判断自己是否接入的是因特网，**首先是看自己电脑是否安装了TCP/IP协议，其次看是否拥有一个公网地址(所谓公网地址，就是所有私网地址以外的地址)**。国际标准的因特网写法是Internet，字母I一定要大写！因特网是基于TCP/IP（与UDP）协议实现的，TCP/IP协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如FTP、SMTP、HTTP。

### 万维网

因特网提供的服务一般包括有：

- **www**（万维网）服务
- 电子邮件服务（outlook）
- 远程登录（QQ）服务
- 文件传输（FTP）服务
- 网络电话
- 其他

**只要应用层使用的是HTTP协议，就称为万维网(World Wide Web)**。之所以在浏览器里输入百度网址时，能看见百度网提供的网页，就是因为您的个人浏览器和百度网的服务器之间使用的是HTTP协议在交流。

---
## 偏函数应用(Partial Application）和函数柯里化(Currying)

- **偏函数**应用指的是固化函数的一个或一些参数，从而产生一个新的函数。比如我们有一个记录日志的函数
- **Currying**指的是将一个具有多个参数的函数，转换成能够通过一系列的函数链式调用，其中每一个函数都只有一个参数。

具体参考[偏函数应用(Partial Application）和函数柯里化(Currying)](http://www.cnblogs.com/cypine/p/3258552.html)

---
## 程序状态

通过逐步跟踪程序的执行步骤，并记录每个变量，即可监视程序的状态，程序状态是在程序的执行过程中，某个给定的点上所有变量的集合。它是计算机当前状态的一个快照。

---
## 数据存储单元的存储形式

Vasual C++ 为每个整型数据分配 4 个字节(32位)，在存储单元中形式是：用整数的补码(complement)形式存放。

- 一个正数的补码是该数据的二进制
- 对于一个负数求补码的方式是：先讲此负数的绝对值写成二进制，然后对其后面所有二进制位按位取反，再加1.

```log
    5的补码是：`00000000 00000101`
    5的源码是：`00000000 00000101`
    按位取反： `11111111 11111010`
    再加一：   `11111111 11111011`即-5的补码
```

在运算较大的数据时，一定要考虑 **溢出** 的问题

### 什么是同步异步，什么是阻塞非阻塞

1. 阻塞和非阻塞，应该描述的是一种状态。
2. 同步与异步描述的是行为方式。

具体参考 [怎样理解阻塞非阻塞与同步异步的区别？](https://www.zhihu.com/question/19732473)

### 编译器的前世今生

1. 最早的编译器是Grace奶奶发明的 A-0 编译器
2. 第二个被大规模应用的编译器，则是和 FORTRAN 编程语言配套的 FORTRAN 编译器。

目前主流使用的编译器主要有下面几种：

1. Windows系统：使用CL编译器。它直接集成在Visual Studio或Visual C++的开发者环境中，一般不单独使用。
2. Linux系统：使用开源的GCC编译器。
3. 苹果 Mac 和 iOS 系统：最初使用GCC编译器，现已替代为Clang + LLVM，LLVM 负责编译器后端，用来处理代码优化和跨平台，而 Clang 负责前端。
4. 安卓系统：安卓主要使用预编译的 Java 语言开发，最初版本通过虚拟机运行，不需要编译器，后续版本加入了 JIT 和 AOT 编译机制。

其他编译器：

- Intel 的 ICC 编译器：全称Intel C++ Compiler，是Intel开发的C/C++/Fortran编译器套装，适用于Linux、Microsoft和Mac OS X操作系统，广泛应用于高性能计算、分布式计算等商业计算领域。
- SGI 等公司推出的 Open64 编译器：SGI（S代表超级计算机，G代表图形工作站，I代表具有突破性的洞察力）生产的超级计算机，主要应用于巨大的实验室，采用Open64编译器。

引用自[方舟编译器](https://mp.weixin.qq.com/s/vnaI8FwB4Ot46weAgq18Eg)

---
## 引用

- [百度百科：UNIX](http://baike.baidu.com/view/8095.htm)
- [维基百科-脚本语言](https://zh.wikipedia.org/wiki/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80)
- [windows10 为什么不把POSIX完整支持了?](https://www.zhihu.com/question/34120198)
- [维基百科：Cygwin](https://zh.wikipedia.org/wiki/Cygwin)
- [维基百科：MinGW](https://zh.wikipedia.org/wiki/MinGW)
- [维基百科：Make](https://zh.wikipedia.org/wiki/Make)
